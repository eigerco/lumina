// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(celestia_typesFFI)
import celestia_typesFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_celestia_types_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_celestia_types_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureCelestiaTypesInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


/**
 * Address of an account.
 */
public struct AccAddress {
    public var id: Id

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Id) {
        self.id = id
    }
}

#if compiler(>=6)
extension AccAddress: Sendable {}
#endif


extension AccAddress: Equatable, Hashable {
    public static func ==(lhs: AccAddress, rhs: AccAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccAddress {
        return
            try AccAddress(
                id: FfiConverterTypeId.read(from: &buf)
        )
    }

    public static func write(_ value: AccAddress, into buf: inout [UInt8]) {
        FfiConverterTypeId.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccAddress_lift(_ buf: RustBuffer) throws -> AccAddress {
    return try FfiConverterTypeAccAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccAddress_lower(_ value: AccAddress) -> RustBuffer {
    return FfiConverterTypeAccAddress.lower(value)
}


public struct AccountId {
    public var id: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data) {
        self.id = id
    }
}

#if compiler(>=6)
extension AccountId: Sendable {}
#endif


extension AccountId: Equatable, Hashable {
    public static func ==(lhs: AccountId, rhs: AccountId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountId {
        return
            try AccountId(
                id: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: AccountId, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountId_lift(_ buf: RustBuffer) throws -> AccountId {
    return try FfiConverterTypeAccountId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountId_lower(_ value: AccountId) -> RustBuffer {
    return FfiConverterTypeAccountId.lower(value)
}


public struct AppHash {
    public var hash: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hash: Data) {
        self.hash = hash
    }
}

#if compiler(>=6)
extension AppHash: Sendable {}
#endif


extension AppHash: Equatable, Hashable {
    public static func ==(lhs: AppHash, rhs: AppHash) -> Bool {
        if lhs.hash != rhs.hash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppHash {
        return
            try AppHash(
                hash: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: AppHash, into buf: inout [UInt8]) {
        FfiConverterData.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppHash_lift(_ buf: RustBuffer) throws -> AppHash {
    return try FfiConverterTypeAppHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppHash_lower(_ value: AppHash) -> RustBuffer {
    return FfiConverterTypeAppHash.lower(value)
}


/**
 * [`AuthInfo`] describes the fee and signer modes that are used to sign a transaction.
 */
public struct AuthInfo {
    /**
     * Defines the signing modes for the required signers.
     *
     * The number and order of elements must match the required signers from transaction
     * [`TxBody`]’s messages. The first element is the primary signer and the one
     * which pays the [`Fee`].
     */
    public var signerInfos: [SignerInfo]
    /**
     * [`Fee`] and gas limit for the transaction.
     *
     * The first signer is the primary signer and the one which pays the fee.
     * The fee can be calculated based on the cost of evaluating the body and doing signature
     * verification of the signers. This can be estimated via simulation.
     */
    public var fee: Fee

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Defines the signing modes for the required signers.
         *
         * The number and order of elements must match the required signers from transaction
         * [`TxBody`]’s messages. The first element is the primary signer and the one
         * which pays the [`Fee`].
         */signerInfos: [SignerInfo], 
        /**
         * [`Fee`] and gas limit for the transaction.
         *
         * The first signer is the primary signer and the one which pays the fee.
         * The fee can be calculated based on the cost of evaluating the body and doing signature
         * verification of the signers. This can be estimated via simulation.
         */fee: Fee) {
        self.signerInfos = signerInfos
        self.fee = fee
    }
}

#if compiler(>=6)
extension AuthInfo: Sendable {}
#endif


extension AuthInfo: Equatable, Hashable {
    public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
        if lhs.signerInfos != rhs.signerInfos {
            return false
        }
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signerInfos)
        hasher.combine(fee)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthInfo {
        return
            try AuthInfo(
                signerInfos: FfiConverterSequenceTypeSignerInfo.read(from: &buf), 
                fee: FfiConverterTypeFee.read(from: &buf)
        )
    }

    public static func write(_ value: AuthInfo, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSignerInfo.write(value.signerInfos, into: &buf)
        FfiConverterTypeFee.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthInfo_lift(_ buf: RustBuffer) throws -> AuthInfo {
    return try FfiConverterTypeAuthInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthInfo_lower(_ value: AuthInfo) -> RustBuffer {
    return FfiConverterTypeAuthInfo.lower(value)
}


/**
 * [`BaseAccount`] defines a base account type.
 *
 * It contains all the necessary fields for basic account functionality.
 *
 * Any custom account type should extend this type for additional functionality
 * (e.g. vesting).
 */
public struct BaseAccount {
    /**
     * Bech32 `AccountId` of this account.
     */
    public var address: Address
    /**
     * Optional `PublicKey` associated with this account.
     */
    public var pubKey: TendermintPublicKey?
    /**
     * `account_number` is the account number of the account in state
     */
    public var accountNumber: UInt64
    /**
     * Sequence of the account, which describes the number of committed transactions signed by a
     * given address.
     */
    public var sequence: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bech32 `AccountId` of this account.
         */address: Address, 
        /**
         * Optional `PublicKey` associated with this account.
         */pubKey: TendermintPublicKey?, 
        /**
         * `account_number` is the account number of the account in state
         */accountNumber: UInt64, 
        /**
         * Sequence of the account, which describes the number of committed transactions signed by a
         * given address.
         */sequence: UInt64) {
        self.address = address
        self.pubKey = pubKey
        self.accountNumber = accountNumber
        self.sequence = sequence
    }
}

#if compiler(>=6)
extension BaseAccount: Sendable {}
#endif


extension BaseAccount: Equatable, Hashable {
    public static func ==(lhs: BaseAccount, rhs: BaseAccount) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.pubKey != rhs.pubKey {
            return false
        }
        if lhs.accountNumber != rhs.accountNumber {
            return false
        }
        if lhs.sequence != rhs.sequence {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(pubKey)
        hasher.combine(accountNumber)
        hasher.combine(sequence)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBaseAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BaseAccount {
        return
            try BaseAccount(
                address: FfiConverterTypeAddress.read(from: &buf), 
                pubKey: FfiConverterOptionTypeTendermintPublicKey.read(from: &buf), 
                accountNumber: FfiConverterUInt64.read(from: &buf), 
                sequence: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BaseAccount, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterOptionTypeTendermintPublicKey.write(value.pubKey, into: &buf)
        FfiConverterUInt64.write(value.accountNumber, into: &buf)
        FfiConverterUInt64.write(value.sequence, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBaseAccount_lift(_ buf: RustBuffer) throws -> BaseAccount {
    return try FfiConverterTypeBaseAccount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBaseAccount_lower(_ value: BaseAccount) -> RustBuffer {
    return FfiConverterTypeBaseAccount.lower(value)
}


public struct BitVector {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension BitVector: Sendable {}
#endif


extension BitVector: Equatable, Hashable {
    public static func ==(lhs: BitVector, rhs: BitVector) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitVector: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitVector {
        return
            try BitVector(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: BitVector, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitVector_lift(_ buf: RustBuffer) throws -> BitVector {
    return try FfiConverterTypeBitVector.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitVector_lower(_ value: BitVector) -> RustBuffer {
    return FfiConverterTypeBitVector.lower(value)
}


/**
 * Arbitrary data that can be stored in the network within certain [`Namespace`].
 */
public struct Blob {
    /**
     * A [`Namespace`] the [`Blob`] belongs to.
     */
    public var namespace: RustNamespace
    /**
     * Data stored within the [`Blob`].
     */
    public var data: Data
    /**
     * Version indicating the format in which [`Share`]s should be created from this [`Blob`].
     */
    public var shareVersion: UInt8
    /**
     * A [`Commitment`] computed from the [`Blob`]s data.
     */
    public var commitment: RustCommitment
    /**
     * Index of the blob's first share in the EDS. Only set for blobs retrieved from chain.
     */
    public var index: UInt64?
    /**
     * A signer of the blob, i.e. address of the account which submitted the blob.
     *
     * Must be present in `share_version 1` and absent otherwise.
     */
    public var signer: AccAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A [`Namespace`] the [`Blob`] belongs to.
         */namespace: RustNamespace, 
        /**
         * Data stored within the [`Blob`].
         */data: Data, 
        /**
         * Version indicating the format in which [`Share`]s should be created from this [`Blob`].
         */shareVersion: UInt8, 
        /**
         * A [`Commitment`] computed from the [`Blob`]s data.
         */commitment: RustCommitment, 
        /**
         * Index of the blob's first share in the EDS. Only set for blobs retrieved from chain.
         */index: UInt64?, 
        /**
         * A signer of the blob, i.e. address of the account which submitted the blob.
         *
         * Must be present in `share_version 1` and absent otherwise.
         */signer: AccAddress?) {
        self.namespace = namespace
        self.data = data
        self.shareVersion = shareVersion
        self.commitment = commitment
        self.index = index
        self.signer = signer
    }
}

#if compiler(>=6)
extension Blob: Sendable {}
#endif


extension Blob: Equatable, Hashable {
    public static func ==(lhs: Blob, rhs: Blob) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.shareVersion != rhs.shareVersion {
            return false
        }
        if lhs.commitment != rhs.commitment {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.signer != rhs.signer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
        hasher.combine(data)
        hasher.combine(shareVersion)
        hasher.combine(commitment)
        hasher.combine(index)
        hasher.combine(signer)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
        return
            try Blob(
                namespace: FfiConverterTypeRustNamespace.read(from: &buf), 
                data: FfiConverterData.read(from: &buf), 
                shareVersion: FfiConverterUInt8.read(from: &buf), 
                commitment: FfiConverterTypeRustCommitment.read(from: &buf), 
                index: FfiConverterOptionUInt64.read(from: &buf), 
                signer: FfiConverterOptionTypeAccAddress.read(from: &buf)
        )
    }

    public static func write(_ value: Blob, into buf: inout [UInt8]) {
        FfiConverterTypeRustNamespace.write(value.namespace, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
        FfiConverterUInt8.write(value.shareVersion, into: &buf)
        FfiConverterTypeRustCommitment.write(value.commitment, into: &buf)
        FfiConverterOptionUInt64.write(value.index, into: &buf)
        FfiConverterOptionTypeAccAddress.write(value.signer, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
    return try FfiConverterTypeBlob.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
    return FfiConverterTypeBlob.lower(value)
}


/**
 * Params defines the parameters for the blob module.
 */
public struct BlobParams {
    /**
     * Gas cost per blob byte
     */
    public var gasPerBlobByte: UInt32
    /**
     * Max square size
     */
    public var govMaxSquareSize: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Gas cost per blob byte
         */gasPerBlobByte: UInt32, 
        /**
         * Max square size
         */govMaxSquareSize: UInt64) {
        self.gasPerBlobByte = gasPerBlobByte
        self.govMaxSquareSize = govMaxSquareSize
    }
}

#if compiler(>=6)
extension BlobParams: Sendable {}
#endif


extension BlobParams: Equatable, Hashable {
    public static func ==(lhs: BlobParams, rhs: BlobParams) -> Bool {
        if lhs.gasPerBlobByte != rhs.gasPerBlobByte {
            return false
        }
        if lhs.govMaxSquareSize != rhs.govMaxSquareSize {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(gasPerBlobByte)
        hasher.combine(govMaxSquareSize)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlobParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobParams {
        return
            try BlobParams(
                gasPerBlobByte: FfiConverterUInt32.read(from: &buf), 
                govMaxSquareSize: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlobParams, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.gasPerBlobByte, into: &buf)
        FfiConverterUInt64.write(value.govMaxSquareSize, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlobParams_lift(_ buf: RustBuffer) throws -> BlobParams {
    return try FfiConverterTypeBlobParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlobParams_lower(_ value: BlobParams) -> RustBuffer {
    return FfiConverterTypeBlobParams.lower(value)
}


/**
 * Blocks consist of a header, transactions, votes (the commit), and a list of
 * evidence of malfeasance (i.e. signing conflicting votes).
 *
 * This is a modified version of [`tendermint::block::Block`] which contains
 * [modifications](data-mod) that Celestia introduced.
 *
 * [data-mod]: https://github.com/celestiaorg/celestia-core/blob/a1268f7ae3e688144a613c8a439dd31818aae07d/proto/tendermint/types/types.proto#L84-L104
 */
public struct Block {
    /**
     * Block header
     */
    public var header: TendermintHeader
    /**
     * Transaction data
     */
    public var data: UniffiData
    /**
     * Evidence of malfeasance
     */
    public var evidence: TendermintEvidenceList
    /**
     * Last commit, should be `None` for the initial block.
     */
    public var lastCommit: TendermintCommit?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Block header
         */header: TendermintHeader, 
        /**
         * Transaction data
         */data: UniffiData, 
        /**
         * Evidence of malfeasance
         */evidence: TendermintEvidenceList, 
        /**
         * Last commit, should be `None` for the initial block.
         */lastCommit: TendermintCommit?) {
        self.header = header
        self.data = data
        self.evidence = evidence
        self.lastCommit = lastCommit
    }
}

#if compiler(>=6)
extension Block: Sendable {}
#endif


extension Block: Equatable, Hashable {
    public static func ==(lhs: Block, rhs: Block) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.evidence != rhs.evidence {
            return false
        }
        if lhs.lastCommit != rhs.lastCommit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(data)
        hasher.combine(evidence)
        hasher.combine(lastCommit)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Block {
        return
            try Block(
                header: FfiConverterTypeTendermintHeader.read(from: &buf), 
                data: FfiConverterTypeUniffiData.read(from: &buf), 
                evidence: FfiConverterTypeTendermintEvidenceList.read(from: &buf), 
                lastCommit: FfiConverterOptionTypeTendermintCommit.read(from: &buf)
        )
    }

    public static func write(_ value: Block, into buf: inout [UInt8]) {
        FfiConverterTypeTendermintHeader.write(value.header, into: &buf)
        FfiConverterTypeUniffiData.write(value.data, into: &buf)
        FfiConverterTypeTendermintEvidenceList.write(value.evidence, into: &buf)
        FfiConverterOptionTypeTendermintCommit.write(value.lastCommit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlock_lift(_ buf: RustBuffer) throws -> Block {
    return try FfiConverterTypeBlock.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlock_lower(_ value: Block) -> RustBuffer {
    return FfiConverterTypeBlock.lower(value)
}


public struct BlockHeight {
    public var value: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt64) {
        self.value = value
    }
}

#if compiler(>=6)
extension BlockHeight: Sendable {}
#endif


extension BlockHeight: Equatable, Hashable {
    public static func ==(lhs: BlockHeight, rhs: BlockHeight) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockHeight: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHeight {
        return
            try BlockHeight(
                value: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlockHeight, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHeight_lift(_ buf: RustBuffer) throws -> BlockHeight {
    return try FfiConverterTypeBlockHeight.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHeight_lower(_ value: BlockHeight) -> RustBuffer {
    return FfiConverterTypeBlockHeight.lower(value)
}


public struct BlockId {
    public var hash: TendermintHash
    public var partSetHeader: PartsHeader

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hash: TendermintHash, partSetHeader: PartsHeader) {
        self.hash = hash
        self.partSetHeader = partSetHeader
    }
}

#if compiler(>=6)
extension BlockId: Sendable {}
#endif


extension BlockId: Equatable, Hashable {
    public static func ==(lhs: BlockId, rhs: BlockId) -> Bool {
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.partSetHeader != rhs.partSetHeader {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hash)
        hasher.combine(partSetHeader)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockId {
        return
            try BlockId(
                hash: FfiConverterTypeTendermintHash.read(from: &buf), 
                partSetHeader: FfiConverterTypePartsHeader.read(from: &buf)
        )
    }

    public static func write(_ value: BlockId, into buf: inout [UInt8]) {
        FfiConverterTypeTendermintHash.write(value.hash, into: &buf)
        FfiConverterTypePartsHeader.write(value.partSetHeader, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lift(_ buf: RustBuffer) throws -> BlockId {
    return try FfiConverterTypeBlockId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockId_lower(_ value: BlockId) -> RustBuffer {
    return FfiConverterTypeBlockId.lower(value)
}


public struct Bytes {
    public var bytes: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Data) {
        self.bytes = bytes
    }
}

#if compiler(>=6)
extension Bytes: Sendable {}
#endif


extension Bytes: Equatable, Hashable {
    public static func ==(lhs: Bytes, rhs: Bytes) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bytes {
        return
            try Bytes(
                bytes: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Bytes, into buf: inout [UInt8]) {
        FfiConverterData.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBytes_lift(_ buf: RustBuffer) throws -> Bytes {
    return try FfiConverterTypeBytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBytes_lower(_ value: Bytes) -> RustBuffer {
    return FfiConverterTypeBytes.lower(value)
}


public struct ChainId {
    public var id: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String) {
        self.id = id
    }
}

#if compiler(>=6)
extension ChainId: Sendable {}
#endif


extension ChainId: Equatable, Hashable {
    public static func ==(lhs: ChainId, rhs: ChainId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainId {
        return
            try ChainId(
                id: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ChainId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainId_lift(_ buf: RustBuffer) throws -> ChainId {
    return try FfiConverterTypeChainId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainId_lower(_ value: ChainId) -> RustBuffer {
    return FfiConverterTypeChainId.lower(value)
}


/**
 * Coin defines a token with a denomination and an amount.
 */
public struct Coin {
    /**
     * Coin denomination
     */
    public var denom: String
    /**
     * Coin amount
     */
    public var amount: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Coin denomination
         */denom: String, 
        /**
         * Coin amount
         */amount: UInt64) {
        self.denom = denom
        self.amount = amount
    }
}

#if compiler(>=6)
extension Coin: Sendable {}
#endif


extension Coin: Equatable, Hashable {
    public static func ==(lhs: Coin, rhs: Coin) -> Bool {
        if lhs.denom != rhs.denom {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(denom)
        hasher.combine(amount)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Coin {
        return
            try Coin(
                denom: FfiConverterString.read(from: &buf), 
                amount: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Coin, into buf: inout [UInt8]) {
        FfiConverterString.write(value.denom, into: &buf)
        FfiConverterUInt64.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoin_lift(_ buf: RustBuffer) throws -> Coin {
    return try FfiConverterTypeCoin.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoin_lower(_ value: Coin) -> RustBuffer {
    return FfiConverterTypeCoin.lower(value)
}


public struct Commit {
    public var height: UInt64
    public var round: UInt32
    public var blockId: BlockId
    public var signatures: [CommitSig]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64, round: UInt32, blockId: BlockId, signatures: [CommitSig]) {
        self.height = height
        self.round = round
        self.blockId = blockId
        self.signatures = signatures
    }
}

#if compiler(>=6)
extension Commit: Sendable {}
#endif


extension Commit: Equatable, Hashable {
    public static func ==(lhs: Commit, rhs: Commit) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.round != rhs.round {
            return false
        }
        if lhs.blockId != rhs.blockId {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(round)
        hasher.combine(blockId)
        hasher.combine(signatures)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Commit {
        return
            try Commit(
                height: FfiConverterUInt64.read(from: &buf), 
                round: FfiConverterUInt32.read(from: &buf), 
                blockId: FfiConverterTypeBlockId.read(from: &buf), 
                signatures: FfiConverterSequenceTypeCommitSig.read(from: &buf)
        )
    }

    public static func write(_ value: Commit, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.height, into: &buf)
        FfiConverterUInt32.write(value.round, into: &buf)
        FfiConverterTypeBlockId.write(value.blockId, into: &buf)
        FfiConverterSequenceTypeCommitSig.write(value.signatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommit_lift(_ buf: RustBuffer) throws -> Commit {
    return try FfiConverterTypeCommit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommit_lower(_ value: Commit) -> RustBuffer {
    return FfiConverterTypeCommit.lower(value)
}


public struct Commitment {
    public var shaHash: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(shaHash: Data) {
        self.shaHash = shaHash
    }
}

#if compiler(>=6)
extension Commitment: Sendable {}
#endif


extension Commitment: Equatable, Hashable {
    public static func ==(lhs: Commitment, rhs: Commitment) -> Bool {
        if lhs.shaHash != rhs.shaHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shaHash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommitment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Commitment {
        return
            try Commitment(
                shaHash: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Commitment, into buf: inout [UInt8]) {
        FfiConverterData.write(value.shaHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitment_lift(_ buf: RustBuffer) throws -> Commitment {
    return try FfiConverterTypeCommitment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitment_lower(_ value: Commitment) -> RustBuffer {
    return FfiConverterTypeCommitment.lower(value)
}


public struct ConflictingBlock {
    public var signedHeader: SignedHeader
    public var validatorSet: ValidatorSet

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signedHeader: SignedHeader, validatorSet: ValidatorSet) {
        self.signedHeader = signedHeader
        self.validatorSet = validatorSet
    }
}

#if compiler(>=6)
extension ConflictingBlock: Sendable {}
#endif


extension ConflictingBlock: Equatable, Hashable {
    public static func ==(lhs: ConflictingBlock, rhs: ConflictingBlock) -> Bool {
        if lhs.signedHeader != rhs.signedHeader {
            return false
        }
        if lhs.validatorSet != rhs.validatorSet {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedHeader)
        hasher.combine(validatorSet)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConflictingBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConflictingBlock {
        return
            try ConflictingBlock(
                signedHeader: FfiConverterTypeSignedHeader.read(from: &buf), 
                validatorSet: FfiConverterTypeValidatorSet.read(from: &buf)
        )
    }

    public static func write(_ value: ConflictingBlock, into buf: inout [UInt8]) {
        FfiConverterTypeSignedHeader.write(value.signedHeader, into: &buf)
        FfiConverterTypeValidatorSet.write(value.validatorSet, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConflictingBlock_lift(_ buf: RustBuffer) throws -> ConflictingBlock {
    return try FfiConverterTypeConflictingBlock.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConflictingBlock_lower(_ value: ConflictingBlock) -> RustBuffer {
    return FfiConverterTypeConflictingBlock.lower(value)
}


/**
 * Address of a consensus node.
 */
public struct ConsAddress {
    public var id: Id

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Id) {
        self.id = id
    }
}

#if compiler(>=6)
extension ConsAddress: Sendable {}
#endif


extension ConsAddress: Equatable, Hashable {
    public static func ==(lhs: ConsAddress, rhs: ConsAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConsAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConsAddress {
        return
            try ConsAddress(
                id: FfiConverterTypeId.read(from: &buf)
        )
    }

    public static func write(_ value: ConsAddress, into buf: inout [UInt8]) {
        FfiConverterTypeId.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConsAddress_lift(_ buf: RustBuffer) throws -> ConsAddress {
    return try FfiConverterTypeConsAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConsAddress_lower(_ value: ConsAddress) -> RustBuffer {
    return FfiConverterTypeConsAddress.lower(value)
}


public struct Event {
    public var type: String
    public var attributes: [EventAttribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, attributes: [EventAttribute]) {
        self.type = type
        self.attributes = attributes
    }
}

#if compiler(>=6)
extension Event: Sendable {}
#endif


extension Event: Equatable, Hashable {
    public static func ==(lhs: Event, rhs: Event) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.attributes != rhs.attributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(attributes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        return
            try Event(
                type: FfiConverterString.read(from: &buf), 
                attributes: FfiConverterSequenceTypeEventAttribute.read(from: &buf)
        )
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterSequenceTypeEventAttribute.write(value.attributes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}


public struct EventAttribute {
    public var key: RawBytes
    public var value: RawBytes
    public var index: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: RawBytes, value: RawBytes, index: Bool) {
        self.key = key
        self.value = value
        self.index = index
    }
}

#if compiler(>=6)
extension EventAttribute: Sendable {}
#endif


extension EventAttribute: Equatable, Hashable {
    public static func ==(lhs: EventAttribute, rhs: EventAttribute) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
        hasher.combine(index)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventAttribute: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventAttribute {
        return
            try EventAttribute(
                key: FfiConverterTypeRawBytes.read(from: &buf), 
                value: FfiConverterTypeRawBytes.read(from: &buf), 
                index: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: EventAttribute, into buf: inout [UInt8]) {
        FfiConverterTypeRawBytes.write(value.key, into: &buf)
        FfiConverterTypeRawBytes.write(value.value, into: &buf)
        FfiConverterBool.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventAttribute_lift(_ buf: RustBuffer) throws -> EventAttribute {
    return try FfiConverterTypeEventAttribute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventAttribute_lower(_ value: EventAttribute) -> RustBuffer {
    return FfiConverterTypeEventAttribute.lower(value)
}


/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 */
public struct Fee {
    /**
     * amount is the amount of coins to be paid as a fee
     */
    public var amount: [Coin]
    /**
     * gas_limit is the maximum gas that can be used in transaction processing
     * before an out of gas error occurs
     */
    public var gasLimit: UInt64
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
     * the payer must be a tx signer (and thus have signed this field in AuthInfo).
     * setting this field does *not* change the ordering of required signers for the transaction.
     */
    public var payer: Address?
    /**
     * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
     * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
     * not support fee grants, this will fail
     */
    public var granter: Address?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * amount is the amount of coins to be paid as a fee
         */amount: [Coin], 
        /**
         * gas_limit is the maximum gas that can be used in transaction processing
         * before an out of gas error occurs
         */gasLimit: UInt64, 
        /**
         * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
         * the payer must be a tx signer (and thus have signed this field in AuthInfo).
         * setting this field does *not* change the ordering of required signers for the transaction.
         */payer: Address?, 
        /**
         * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
         * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
         * not support fee grants, this will fail
         */granter: Address?) {
        self.amount = amount
        self.gasLimit = gasLimit
        self.payer = payer
        self.granter = granter
    }
}

#if compiler(>=6)
extension Fee: Sendable {}
#endif


extension Fee: Equatable, Hashable {
    public static func ==(lhs: Fee, rhs: Fee) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.gasLimit != rhs.gasLimit {
            return false
        }
        if lhs.payer != rhs.payer {
            return false
        }
        if lhs.granter != rhs.granter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(gasLimit)
        hasher.combine(payer)
        hasher.combine(granter)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fee {
        return
            try Fee(
                amount: FfiConverterSequenceTypeCoin.read(from: &buf), 
                gasLimit: FfiConverterUInt64.read(from: &buf), 
                payer: FfiConverterOptionTypeAddress.read(from: &buf), 
                granter: FfiConverterOptionTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: Fee, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeCoin.write(value.amount, into: &buf)
        FfiConverterUInt64.write(value.gasLimit, into: &buf)
        FfiConverterOptionTypeAddress.write(value.payer, into: &buf)
        FfiConverterOptionTypeAddress.write(value.granter, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lift(_ buf: RustBuffer) throws -> Fee {
    return try FfiConverterTypeFee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFee_lower(_ value: Fee) -> RustBuffer {
    return FfiConverterTypeFee.lower(value)
}


public struct Header {
    public var version: ProtocolVersion
    public var chainId: ChainId
    public var height: TendermintHeight
    public var time: Time
    public var lastBlockId: BlockId?
    public var lastCommitHash: TendermintHash?
    public var dataHash: TendermintHash?
    public var validatorsHash: TendermintHash
    public var nextValidatorsHash: TendermintHash
    public var consensusHash: TendermintHash
    public var appHash: AppHash
    public var lastResultsHash: TendermintHash?
    public var evidenceHash: TendermintHash?
    public var proposerAddress: AccountId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: ProtocolVersion, chainId: ChainId, height: TendermintHeight, time: Time, lastBlockId: BlockId?, lastCommitHash: TendermintHash?, dataHash: TendermintHash?, validatorsHash: TendermintHash, nextValidatorsHash: TendermintHash, consensusHash: TendermintHash, appHash: AppHash, lastResultsHash: TendermintHash?, evidenceHash: TendermintHash?, proposerAddress: AccountId) {
        self.version = version
        self.chainId = chainId
        self.height = height
        self.time = time
        self.lastBlockId = lastBlockId
        self.lastCommitHash = lastCommitHash
        self.dataHash = dataHash
        self.validatorsHash = validatorsHash
        self.nextValidatorsHash = nextValidatorsHash
        self.consensusHash = consensusHash
        self.appHash = appHash
        self.lastResultsHash = lastResultsHash
        self.evidenceHash = evidenceHash
        self.proposerAddress = proposerAddress
    }
}

#if compiler(>=6)
extension Header: Sendable {}
#endif


extension Header: Equatable, Hashable {
    public static func ==(lhs: Header, rhs: Header) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.chainId != rhs.chainId {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.lastBlockId != rhs.lastBlockId {
            return false
        }
        if lhs.lastCommitHash != rhs.lastCommitHash {
            return false
        }
        if lhs.dataHash != rhs.dataHash {
            return false
        }
        if lhs.validatorsHash != rhs.validatorsHash {
            return false
        }
        if lhs.nextValidatorsHash != rhs.nextValidatorsHash {
            return false
        }
        if lhs.consensusHash != rhs.consensusHash {
            return false
        }
        if lhs.appHash != rhs.appHash {
            return false
        }
        if lhs.lastResultsHash != rhs.lastResultsHash {
            return false
        }
        if lhs.evidenceHash != rhs.evidenceHash {
            return false
        }
        if lhs.proposerAddress != rhs.proposerAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(chainId)
        hasher.combine(height)
        hasher.combine(time)
        hasher.combine(lastBlockId)
        hasher.combine(lastCommitHash)
        hasher.combine(dataHash)
        hasher.combine(validatorsHash)
        hasher.combine(nextValidatorsHash)
        hasher.combine(consensusHash)
        hasher.combine(appHash)
        hasher.combine(lastResultsHash)
        hasher.combine(evidenceHash)
        hasher.combine(proposerAddress)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                version: FfiConverterTypeProtocolVersion.read(from: &buf), 
                chainId: FfiConverterTypeChainId.read(from: &buf), 
                height: FfiConverterTypeTendermintHeight.read(from: &buf), 
                time: FfiConverterTypeTime.read(from: &buf), 
                lastBlockId: FfiConverterOptionTypeBlockId.read(from: &buf), 
                lastCommitHash: FfiConverterOptionTypeTendermintHash.read(from: &buf), 
                dataHash: FfiConverterOptionTypeTendermintHash.read(from: &buf), 
                validatorsHash: FfiConverterTypeTendermintHash.read(from: &buf), 
                nextValidatorsHash: FfiConverterTypeTendermintHash.read(from: &buf), 
                consensusHash: FfiConverterTypeTendermintHash.read(from: &buf), 
                appHash: FfiConverterTypeAppHash.read(from: &buf), 
                lastResultsHash: FfiConverterOptionTypeTendermintHash.read(from: &buf), 
                evidenceHash: FfiConverterOptionTypeTendermintHash.read(from: &buf), 
                proposerAddress: FfiConverterTypeAccountId.read(from: &buf)
        )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProtocolVersion.write(value.version, into: &buf)
        FfiConverterTypeChainId.write(value.chainId, into: &buf)
        FfiConverterTypeTendermintHeight.write(value.height, into: &buf)
        FfiConverterTypeTime.write(value.time, into: &buf)
        FfiConverterOptionTypeBlockId.write(value.lastBlockId, into: &buf)
        FfiConverterOptionTypeTendermintHash.write(value.lastCommitHash, into: &buf)
        FfiConverterOptionTypeTendermintHash.write(value.dataHash, into: &buf)
        FfiConverterTypeTendermintHash.write(value.validatorsHash, into: &buf)
        FfiConverterTypeTendermintHash.write(value.nextValidatorsHash, into: &buf)
        FfiConverterTypeTendermintHash.write(value.consensusHash, into: &buf)
        FfiConverterTypeAppHash.write(value.appHash, into: &buf)
        FfiConverterOptionTypeTendermintHash.write(value.lastResultsHash, into: &buf)
        FfiConverterOptionTypeTendermintHash.write(value.evidenceHash, into: &buf)
        FfiConverterTypeAccountId.write(value.proposerAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}


/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 */
public struct ModeInfo {
    /**
     * sum is the oneof that specifies whether this represents a single or nested
     * multisig signer
     */
    public var sum: Sum

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * sum is the oneof that specifies whether this represents a single or nested
         * multisig signer
         */sum: Sum) {
        self.sum = sum
    }
}

#if compiler(>=6)
extension ModeInfo: Sendable {}
#endif


extension ModeInfo: Equatable, Hashable {
    public static func ==(lhs: ModeInfo, rhs: ModeInfo) -> Bool {
        if lhs.sum != rhs.sum {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sum)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModeInfo {
        return
            try ModeInfo(
                sum: FfiConverterTypeSum.read(from: &buf)
        )
    }

    public static func write(_ value: ModeInfo, into buf: inout [UInt8]) {
        FfiConverterTypeSum.write(value.sum, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModeInfo_lift(_ buf: RustBuffer) throws -> ModeInfo {
    return try FfiConverterTypeModeInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModeInfo_lower(_ value: ModeInfo) -> RustBuffer {
    return FfiConverterTypeModeInfo.lower(value)
}


/**
 * [`ModuleAccount`] defines an account for modules that holds coins on a pool.
 */
public struct ModuleAccount {
    /**
     * [`BaseAccount`] specification of this module account.
     */
    public var baseAccount: BaseAccount
    /**
     * Name of the module.
     */
    public var name: String
    /**
     * Permissions associated with this module account.
     */
    public var permissions: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * [`BaseAccount`] specification of this module account.
         */baseAccount: BaseAccount, 
        /**
         * Name of the module.
         */name: String, 
        /**
         * Permissions associated with this module account.
         */permissions: [String]) {
        self.baseAccount = baseAccount
        self.name = name
        self.permissions = permissions
    }
}

#if compiler(>=6)
extension ModuleAccount: Sendable {}
#endif


extension ModuleAccount: Equatable, Hashable {
    public static func ==(lhs: ModuleAccount, rhs: ModuleAccount) -> Bool {
        if lhs.baseAccount != rhs.baseAccount {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.permissions != rhs.permissions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseAccount)
        hasher.combine(name)
        hasher.combine(permissions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeModuleAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModuleAccount {
        return
            try ModuleAccount(
                baseAccount: FfiConverterTypeBaseAccount.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                permissions: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ModuleAccount, into buf: inout [UInt8]) {
        FfiConverterTypeBaseAccount.write(value.baseAccount, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceString.write(value.permissions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleAccount_lift(_ buf: RustBuffer) throws -> ModuleAccount {
    return try FfiConverterTypeModuleAccount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeModuleAccount_lower(_ value: ModuleAccount) -> RustBuffer {
    return FfiConverterTypeModuleAccount.lower(value)
}


public struct Namespace {
    public var namespace: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(namespace: Data) {
        self.namespace = namespace
    }
}

#if compiler(>=6)
extension Namespace: Sendable {}
#endif


extension Namespace: Equatable, Hashable {
    public static func ==(lhs: Namespace, rhs: Namespace) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNamespace: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Namespace {
        return
            try Namespace(
                namespace: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Namespace, into buf: inout [UInt8]) {
        FfiConverterData.write(value.namespace, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNamespace_lift(_ buf: RustBuffer) throws -> Namespace {
    return try FfiConverterTypeNamespace.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNamespace_lower(_ value: Namespace) -> RustBuffer {
    return FfiConverterTypeNamespace.lower(value)
}


public struct PartsHeader {
    public var total: UInt32
    public var hash: TendermintHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(total: UInt32, hash: TendermintHash) {
        self.total = total
        self.hash = hash
    }
}

#if compiler(>=6)
extension PartsHeader: Sendable {}
#endif


extension PartsHeader: Equatable, Hashable {
    public static func ==(lhs: PartsHeader, rhs: PartsHeader) -> Bool {
        if lhs.total != rhs.total {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(total)
        hasher.combine(hash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePartsHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PartsHeader {
        return
            try PartsHeader(
                total: FfiConverterUInt32.read(from: &buf), 
                hash: FfiConverterTypeTendermintHash.read(from: &buf)
        )
    }

    public static func write(_ value: PartsHeader, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.total, into: &buf)
        FfiConverterTypeTendermintHash.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePartsHeader_lift(_ buf: RustBuffer) throws -> PartsHeader {
    return try FfiConverterTypePartsHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePartsHeader_lower(_ value: PartsHeader) -> RustBuffer {
    return FfiConverterTypePartsHeader.lower(value)
}


public struct ProtobufAny {
    public var typeUrl: String
    public var value: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeUrl: String, value: Data) {
        self.typeUrl = typeUrl
        self.value = value
    }
}

#if compiler(>=6)
extension ProtobufAny: Sendable {}
#endif


extension ProtobufAny: Equatable, Hashable {
    public static func ==(lhs: ProtobufAny, rhs: ProtobufAny) -> Bool {
        if lhs.typeUrl != rhs.typeUrl {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeUrl)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProtobufAny: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtobufAny {
        return
            try ProtobufAny(
                typeUrl: FfiConverterString.read(from: &buf), 
                value: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: ProtobufAny, into buf: inout [UInt8]) {
        FfiConverterString.write(value.typeUrl, into: &buf)
        FfiConverterData.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtobufAny_lift(_ buf: RustBuffer) throws -> ProtobufAny {
    return try FfiConverterTypeProtobufAny.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtobufAny_lower(_ value: ProtobufAny) -> RustBuffer {
    return FfiConverterTypeProtobufAny.lower(value)
}


public struct ProtocolVersion {
    public var block: UInt64
    public var app: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(block: UInt64, app: UInt64) {
        self.block = block
        self.app = app
    }
}

#if compiler(>=6)
extension ProtocolVersion: Sendable {}
#endif


extension ProtocolVersion: Equatable, Hashable {
    public static func ==(lhs: ProtocolVersion, rhs: ProtocolVersion) -> Bool {
        if lhs.block != rhs.block {
            return false
        }
        if lhs.app != rhs.app {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(block)
        hasher.combine(app)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProtocolVersion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProtocolVersion {
        return
            try ProtocolVersion(
                block: FfiConverterUInt64.read(from: &buf), 
                app: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ProtocolVersion, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.block, into: &buf)
        FfiConverterUInt64.write(value.app, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersion_lift(_ buf: RustBuffer) throws -> ProtocolVersion {
    return try FfiConverterTypeProtocolVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProtocolVersion_lower(_ value: ProtocolVersion) -> RustBuffer {
    return FfiConverterTypeProtocolVersion.lower(value)
}


public struct Signature {
    public var signature: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signature: Data) {
        self.signature = signature
    }
}

#if compiler(>=6)
extension Signature: Sendable {}
#endif


extension Signature: Equatable, Hashable {
    public static func ==(lhs: Signature, rhs: Signature) -> Bool {
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signature)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        return
            try Signature(
                signature: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        FfiConverterData.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}


public struct SignedHeader {
    public var header: Header
    public var commit: Commit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: Header, commit: Commit) {
        self.header = header
        self.commit = commit
    }
}

#if compiler(>=6)
extension SignedHeader: Sendable {}
#endif


extension SignedHeader: Equatable, Hashable {
    public static func ==(lhs: SignedHeader, rhs: SignedHeader) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.commit != rhs.commit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(commit)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedHeader {
        return
            try SignedHeader(
                header: FfiConverterTypeHeader.read(from: &buf), 
                commit: FfiConverterTypeCommit.read(from: &buf)
        )
    }

    public static func write(_ value: SignedHeader, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterTypeCommit.write(value.commit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedHeader_lift(_ buf: RustBuffer) throws -> SignedHeader {
    return try FfiConverterTypeSignedHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedHeader_lower(_ value: SignedHeader) -> RustBuffer {
    return FfiConverterTypeSignedHeader.lower(value)
}


/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 */
public struct SignerInfo {
    /**
     * public_key is the public key of the signer. It is optional for accounts
     * that already exist in state. If unset, the verifier can use the required \
     * signer address for this position and lookup the public key.
     */
    public var publicKey: ProtobufAny?
    /**
     * mode_info describes the signing mode of the signer and is a nested
     * structure to support nested multisig pubkey's
     */
    public var modeInfo: ModeInfo
    /**
     * sequence is the sequence of the account, which describes the
     * number of committed transactions signed by a given address. It is used to
     * prevent replay attacks.
     */
    public var sequence: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * public_key is the public key of the signer. It is optional for accounts
         * that already exist in state. If unset, the verifier can use the required \
         * signer address for this position and lookup the public key.
         */publicKey: ProtobufAny?, 
        /**
         * mode_info describes the signing mode of the signer and is a nested
         * structure to support nested multisig pubkey's
         */modeInfo: ModeInfo, 
        /**
         * sequence is the sequence of the account, which describes the
         * number of committed transactions signed by a given address. It is used to
         * prevent replay attacks.
         */sequence: UInt64) {
        self.publicKey = publicKey
        self.modeInfo = modeInfo
        self.sequence = sequence
    }
}

#if compiler(>=6)
extension SignerInfo: Sendable {}
#endif


extension SignerInfo: Equatable, Hashable {
    public static func ==(lhs: SignerInfo, rhs: SignerInfo) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.modeInfo != rhs.modeInfo {
            return false
        }
        if lhs.sequence != rhs.sequence {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(modeInfo)
        hasher.combine(sequence)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignerInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerInfo {
        return
            try SignerInfo(
                publicKey: FfiConverterOptionTypeProtobufAny.read(from: &buf), 
                modeInfo: FfiConverterTypeModeInfo.read(from: &buf), 
                sequence: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SignerInfo, into buf: inout [UInt8]) {
        FfiConverterOptionTypeProtobufAny.write(value.publicKey, into: &buf)
        FfiConverterTypeModeInfo.write(value.modeInfo, into: &buf)
        FfiConverterUInt64.write(value.sequence, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerInfo_lift(_ buf: RustBuffer) throws -> SignerInfo {
    return try FfiConverterTypeSignerInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignerInfo_lower(_ value: SignerInfo) -> RustBuffer {
    return FfiConverterTypeSignerInfo.lower(value)
}


public struct Time {
    public var ts: Int64
    public var nanos: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ts: Int64, nanos: UInt32) {
        self.ts = ts
        self.nanos = nanos
    }
}

#if compiler(>=6)
extension Time: Sendable {}
#endif


extension Time: Equatable, Hashable {
    public static func ==(lhs: Time, rhs: Time) -> Bool {
        if lhs.ts != rhs.ts {
            return false
        }
        if lhs.nanos != rhs.nanos {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ts)
        hasher.combine(nanos)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Time {
        return
            try Time(
                ts: FfiConverterInt64.read(from: &buf), 
                nanos: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Time, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.ts, into: &buf)
        FfiConverterUInt32.write(value.nanos, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTime_lift(_ buf: RustBuffer) throws -> Time {
    return try FfiConverterTypeTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTime_lower(_ value: Time) -> RustBuffer {
    return FfiConverterTypeTime.lower(value)
}


/**
 * [`Tx`] is the standard type used for broadcasting transactions.
 */
public struct Tx {
    /**
     * Processable content of the transaction
     */
    public var body: TxBody
    /**
     * Authorization related content of the transaction, specifically signers, signer modes
     * and [`Fee`].
     */
    public var authInfo: AuthInfo
    /**
     * List of signatures that matches the length and order of [`AuthInfo`]’s `signer_info`s to
     * allow connecting signature meta information like public key and signing mode by position.
     *
     * Signatures are provided as raw bytes so as to support current and future signature types.
     * [`AuthInfo`] should be introspected to determine the signature algorithm used.
     */
    public var signatures: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Processable content of the transaction
         */body: TxBody, 
        /**
         * Authorization related content of the transaction, specifically signers, signer modes
         * and [`Fee`].
         */authInfo: AuthInfo, 
        /**
         * List of signatures that matches the length and order of [`AuthInfo`]’s `signer_info`s to
         * allow connecting signature meta information like public key and signing mode by position.
         *
         * Signatures are provided as raw bytes so as to support current and future signature types.
         * [`AuthInfo`] should be introspected to determine the signature algorithm used.
         */signatures: [Data]) {
        self.body = body
        self.authInfo = authInfo
        self.signatures = signatures
    }
}

#if compiler(>=6)
extension Tx: Sendable {}
#endif


extension Tx: Equatable, Hashable {
    public static func ==(lhs: Tx, rhs: Tx) -> Bool {
        if lhs.body != rhs.body {
            return false
        }
        if lhs.authInfo != rhs.authInfo {
            return false
        }
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(body)
        hasher.combine(authInfo)
        hasher.combine(signatures)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTx: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tx {
        return
            try Tx(
                body: FfiConverterTypeTxBody.read(from: &buf), 
                authInfo: FfiConverterTypeAuthInfo.read(from: &buf), 
                signatures: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: Tx, into buf: inout [UInt8]) {
        FfiConverterTypeTxBody.write(value.body, into: &buf)
        FfiConverterTypeAuthInfo.write(value.authInfo, into: &buf)
        FfiConverterSequenceData.write(value.signatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lift(_ buf: RustBuffer) throws -> Tx {
    return try FfiConverterTypeTx.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTx_lower(_ value: Tx) -> RustBuffer {
    return FfiConverterTypeTx.lower(value)
}


/**
 * [`TxBody`] of a transaction that all signers sign over.
 */
public struct TxBody {
    /**
     * `messages` is a list of messages to be executed. The required signers of
     * those messages define the number and order of elements in `AuthInfo`'s
     * signer_infos and Tx's signatures. Each required signer address is added to
     * the list only the first time it occurs.
     *
     * By convention, the first required signer (usually from the first message)
     * is referred to as the primary signer and pays the fee for the whole
     * transaction.
     */
    public var messages: [ProtobufAny]
    /**
     * `memo` is any arbitrary memo to be added to the transaction.
     */
    public var memo: String
    /**
     * `timeout` is the block height after which this transaction will not
     * be processed by the chain
     */
    public var timeoutHeight: TendermintHeight
    /**
     * `extension_options` are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, the transaction will be rejected
     */
    public var extensionOptions: [ProtobufAny]
    /**
     * `extension_options` are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, they will be ignored
     */
    public var nonCriticalExtensionOptions: [ProtobufAny]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * `messages` is a list of messages to be executed. The required signers of
         * those messages define the number and order of elements in `AuthInfo`'s
         * signer_infos and Tx's signatures. Each required signer address is added to
         * the list only the first time it occurs.
         *
         * By convention, the first required signer (usually from the first message)
         * is referred to as the primary signer and pays the fee for the whole
         * transaction.
         */messages: [ProtobufAny], 
        /**
         * `memo` is any arbitrary memo to be added to the transaction.
         */memo: String, 
        /**
         * `timeout` is the block height after which this transaction will not
         * be processed by the chain
         */timeoutHeight: TendermintHeight, 
        /**
         * `extension_options` are arbitrary options that can be added by chains
         * when the default options are not sufficient. If any of these are present
         * and can't be handled, the transaction will be rejected
         */extensionOptions: [ProtobufAny], 
        /**
         * `extension_options` are arbitrary options that can be added by chains
         * when the default options are not sufficient. If any of these are present
         * and can't be handled, they will be ignored
         */nonCriticalExtensionOptions: [ProtobufAny]) {
        self.messages = messages
        self.memo = memo
        self.timeoutHeight = timeoutHeight
        self.extensionOptions = extensionOptions
        self.nonCriticalExtensionOptions = nonCriticalExtensionOptions
    }
}

#if compiler(>=6)
extension TxBody: Sendable {}
#endif


extension TxBody: Equatable, Hashable {
    public static func ==(lhs: TxBody, rhs: TxBody) -> Bool {
        if lhs.messages != rhs.messages {
            return false
        }
        if lhs.memo != rhs.memo {
            return false
        }
        if lhs.timeoutHeight != rhs.timeoutHeight {
            return false
        }
        if lhs.extensionOptions != rhs.extensionOptions {
            return false
        }
        if lhs.nonCriticalExtensionOptions != rhs.nonCriticalExtensionOptions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messages)
        hasher.combine(memo)
        hasher.combine(timeoutHeight)
        hasher.combine(extensionOptions)
        hasher.combine(nonCriticalExtensionOptions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxBody {
        return
            try TxBody(
                messages: FfiConverterSequenceTypeProtobufAny.read(from: &buf), 
                memo: FfiConverterString.read(from: &buf), 
                timeoutHeight: FfiConverterTypeTendermintHeight.read(from: &buf), 
                extensionOptions: FfiConverterSequenceTypeProtobufAny.read(from: &buf), 
                nonCriticalExtensionOptions: FfiConverterSequenceTypeProtobufAny.read(from: &buf)
        )
    }

    public static func write(_ value: TxBody, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeProtobufAny.write(value.messages, into: &buf)
        FfiConverterString.write(value.memo, into: &buf)
        FfiConverterTypeTendermintHeight.write(value.timeoutHeight, into: &buf)
        FfiConverterSequenceTypeProtobufAny.write(value.extensionOptions, into: &buf)
        FfiConverterSequenceTypeProtobufAny.write(value.nonCriticalExtensionOptions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBody_lift(_ buf: RustBuffer) throws -> TxBody {
    return try FfiConverterTypeTxBody.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxBody_lower(_ value: TxBody) -> RustBuffer {
    return FfiConverterTypeTxBody.lower(value)
}


/**
 * Response to a tx query
 */
public struct TxResponse {
    /**
     * The block height
     */
    public var height: TendermintHeight
    /**
     * The transaction hash.
     */
    public var txhash: TendermintHash
    /**
     * Namespace for the Code
     */
    public var codespace: String
    /**
     * Response code.
     */
    public var code: ErrorCode
    /**
     * Result bytes, if any.
     */
    public var data: String
    /**
     * The output of the application's logger (raw string). May be
     * non-deterministic.
     */
    public var rawLog: String
    /**
     * The output of the application's logger (typed). May be non-deterministic.
     */
    public var logs: [AbciMessageLog]
    /**
     * Additional information. May be non-deterministic.
     */
    public var info: String
    /**
     * Amount of gas requested for transaction.
     */
    public var gasWanted: Int64
    /**
     * Amount of gas consumed by transaction.
     */
    public var gasUsed: Int64
    /**
     * The request transaction bytes.
     */
    public var tx: ProtobufAny?
    /**
     * Time of the previous block. For heights > 1, it's the weighted median of
     * the timestamps of the valid votes in the block.LastCommit. For height == 1,
     * it's genesis time.
     */
    public var timestamp: String
    /**
     * Events defines all the events emitted by processing a transaction. Note,
     * these events include those emitted by processing all the messages and those
     * emitted from the ante. Whereas Logs contains the events, with
     * additional metadata, emitted only by processing the messages.
     */
    public var events: [Event]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The block height
         */height: TendermintHeight, 
        /**
         * The transaction hash.
         */txhash: TendermintHash, 
        /**
         * Namespace for the Code
         */codespace: String, 
        /**
         * Response code.
         */code: ErrorCode, 
        /**
         * Result bytes, if any.
         */data: String, 
        /**
         * The output of the application's logger (raw string). May be
         * non-deterministic.
         */rawLog: String, 
        /**
         * The output of the application's logger (typed). May be non-deterministic.
         */logs: [AbciMessageLog], 
        /**
         * Additional information. May be non-deterministic.
         */info: String, 
        /**
         * Amount of gas requested for transaction.
         */gasWanted: Int64, 
        /**
         * Amount of gas consumed by transaction.
         */gasUsed: Int64, 
        /**
         * The request transaction bytes.
         */tx: ProtobufAny?, 
        /**
         * Time of the previous block. For heights > 1, it's the weighted median of
         * the timestamps of the valid votes in the block.LastCommit. For height == 1,
         * it's genesis time.
         */timestamp: String, 
        /**
         * Events defines all the events emitted by processing a transaction. Note,
         * these events include those emitted by processing all the messages and those
         * emitted from the ante. Whereas Logs contains the events, with
         * additional metadata, emitted only by processing the messages.
         */events: [Event]) {
        self.height = height
        self.txhash = txhash
        self.codespace = codespace
        self.code = code
        self.data = data
        self.rawLog = rawLog
        self.logs = logs
        self.info = info
        self.gasWanted = gasWanted
        self.gasUsed = gasUsed
        self.tx = tx
        self.timestamp = timestamp
        self.events = events
    }
}

#if compiler(>=6)
extension TxResponse: Sendable {}
#endif


extension TxResponse: Equatable, Hashable {
    public static func ==(lhs: TxResponse, rhs: TxResponse) -> Bool {
        if lhs.height != rhs.height {
            return false
        }
        if lhs.txhash != rhs.txhash {
            return false
        }
        if lhs.codespace != rhs.codespace {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.rawLog != rhs.rawLog {
            return false
        }
        if lhs.logs != rhs.logs {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        if lhs.gasWanted != rhs.gasWanted {
            return false
        }
        if lhs.gasUsed != rhs.gasUsed {
            return false
        }
        if lhs.tx != rhs.tx {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.events != rhs.events {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(height)
        hasher.combine(txhash)
        hasher.combine(codespace)
        hasher.combine(code)
        hasher.combine(data)
        hasher.combine(rawLog)
        hasher.combine(logs)
        hasher.combine(info)
        hasher.combine(gasWanted)
        hasher.combine(gasUsed)
        hasher.combine(tx)
        hasher.combine(timestamp)
        hasher.combine(events)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxResponse {
        return
            try TxResponse(
                height: FfiConverterTypeTendermintHeight.read(from: &buf), 
                txhash: FfiConverterTypeTendermintHash.read(from: &buf), 
                codespace: FfiConverterString.read(from: &buf), 
                code: FfiConverterTypeErrorCode.read(from: &buf), 
                data: FfiConverterString.read(from: &buf), 
                rawLog: FfiConverterString.read(from: &buf), 
                logs: FfiConverterSequenceTypeAbciMessageLog.read(from: &buf), 
                info: FfiConverterString.read(from: &buf), 
                gasWanted: FfiConverterInt64.read(from: &buf), 
                gasUsed: FfiConverterInt64.read(from: &buf), 
                tx: FfiConverterOptionTypeProtobufAny.read(from: &buf), 
                timestamp: FfiConverterString.read(from: &buf), 
                events: FfiConverterSequenceTypeEvent.read(from: &buf)
        )
    }

    public static func write(_ value: TxResponse, into buf: inout [UInt8]) {
        FfiConverterTypeTendermintHeight.write(value.height, into: &buf)
        FfiConverterTypeTendermintHash.write(value.txhash, into: &buf)
        FfiConverterString.write(value.codespace, into: &buf)
        FfiConverterTypeErrorCode.write(value.code, into: &buf)
        FfiConverterString.write(value.data, into: &buf)
        FfiConverterString.write(value.rawLog, into: &buf)
        FfiConverterSequenceTypeAbciMessageLog.write(value.logs, into: &buf)
        FfiConverterString.write(value.info, into: &buf)
        FfiConverterInt64.write(value.gasWanted, into: &buf)
        FfiConverterInt64.write(value.gasUsed, into: &buf)
        FfiConverterOptionTypeProtobufAny.write(value.tx, into: &buf)
        FfiConverterString.write(value.timestamp, into: &buf)
        FfiConverterSequenceTypeEvent.write(value.events, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxResponse_lift(_ buf: RustBuffer) throws -> TxResponse {
    return try FfiConverterTypeTxResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxResponse_lower(_ value: TxResponse) -> RustBuffer {
    return FfiConverterTypeTxResponse.lower(value)
}


public struct UniffiData {
    /**
     * Transactions.
     */
    public var txs: [Data]
    /**
     * Square width of original data square.
     */
    public var squareSize: UInt64
    /**
     * Hash is the root of a binary Merkle tree where the leaves of the tree are
     * the row and column roots of an extended data square. Hash is often referred
     * to as the "data root".
     */
    public var hash: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Transactions.
         */txs: [Data], 
        /**
         * Square width of original data square.
         */squareSize: UInt64, 
        /**
         * Hash is the root of a binary Merkle tree where the leaves of the tree are
         * the row and column roots of an extended data square. Hash is often referred
         * to as the "data root".
         */hash: Data) {
        self.txs = txs
        self.squareSize = squareSize
        self.hash = hash
    }
}

#if compiler(>=6)
extension UniffiData: Sendable {}
#endif


extension UniffiData: Equatable, Hashable {
    public static func ==(lhs: UniffiData, rhs: UniffiData) -> Bool {
        if lhs.txs != rhs.txs {
            return false
        }
        if lhs.squareSize != rhs.squareSize {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txs)
        hasher.combine(squareSize)
        hasher.combine(hash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUniffiData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiData {
        return
            try UniffiData(
                txs: FfiConverterSequenceData.read(from: &buf), 
                squareSize: FfiConverterUInt64.read(from: &buf), 
                hash: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: UniffiData, into buf: inout [UInt8]) {
        FfiConverterSequenceData.write(value.txs, into: &buf)
        FfiConverterUInt64.write(value.squareSize, into: &buf)
        FfiConverterData.write(value.hash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiData_lift(_ buf: RustBuffer) throws -> UniffiData {
    return try FfiConverterTypeUniffiData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiData_lower(_ value: UniffiData) -> RustBuffer {
    return FfiConverterTypeUniffiData.lower(value)
}


/**
 * Address of a validator.
 */
public struct ValAddress {
    public var id: Id

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Id) {
        self.id = id
    }
}

#if compiler(>=6)
extension ValAddress: Sendable {}
#endif


extension ValAddress: Equatable, Hashable {
    public static func ==(lhs: ValAddress, rhs: ValAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValAddress {
        return
            try ValAddress(
                id: FfiConverterTypeId.read(from: &buf)
        )
    }

    public static func write(_ value: ValAddress, into buf: inout [UInt8]) {
        FfiConverterTypeId.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValAddress_lift(_ buf: RustBuffer) throws -> ValAddress {
    return try FfiConverterTypeValAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValAddress_lower(_ value: ValAddress) -> RustBuffer {
    return FfiConverterTypeValAddress.lower(value)
}


public struct ValidatorInfo {
    public var address: AccountId
    public var pubKey: TendermintPublicKey
    public var power: UInt64
    public var name: String?
    public var proposerPriority: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountId, pubKey: TendermintPublicKey, power: UInt64, name: String?, proposerPriority: Int64) {
        self.address = address
        self.pubKey = pubKey
        self.power = power
        self.name = name
        self.proposerPriority = proposerPriority
    }
}

#if compiler(>=6)
extension ValidatorInfo: Sendable {}
#endif


extension ValidatorInfo: Equatable, Hashable {
    public static func ==(lhs: ValidatorInfo, rhs: ValidatorInfo) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.pubKey != rhs.pubKey {
            return false
        }
        if lhs.power != rhs.power {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.proposerPriority != rhs.proposerPriority {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(pubKey)
        hasher.combine(power)
        hasher.combine(name)
        hasher.combine(proposerPriority)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidatorInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorInfo {
        return
            try ValidatorInfo(
                address: FfiConverterTypeAccountId.read(from: &buf), 
                pubKey: FfiConverterTypeTendermintPublicKey.read(from: &buf), 
                power: FfiConverterUInt64.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                proposerPriority: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorInfo, into buf: inout [UInt8]) {
        FfiConverterTypeAccountId.write(value.address, into: &buf)
        FfiConverterTypeTendermintPublicKey.write(value.pubKey, into: &buf)
        FfiConverterUInt64.write(value.power, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterInt64.write(value.proposerPriority, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorInfo_lift(_ buf: RustBuffer) throws -> ValidatorInfo {
    return try FfiConverterTypeValidatorInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorInfo_lower(_ value: ValidatorInfo) -> RustBuffer {
    return FfiConverterTypeValidatorInfo.lower(value)
}


public struct ValidatorSet {
    public var validators: [ValidatorInfo]
    public var proposer: ValidatorInfo?
    public var totalVotingPower: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validators: [ValidatorInfo], proposer: ValidatorInfo?, totalVotingPower: UInt64) {
        self.validators = validators
        self.proposer = proposer
        self.totalVotingPower = totalVotingPower
    }
}

#if compiler(>=6)
extension ValidatorSet: Sendable {}
#endif


extension ValidatorSet: Equatable, Hashable {
    public static func ==(lhs: ValidatorSet, rhs: ValidatorSet) -> Bool {
        if lhs.validators != rhs.validators {
            return false
        }
        if lhs.proposer != rhs.proposer {
            return false
        }
        if lhs.totalVotingPower != rhs.totalVotingPower {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validators)
        hasher.combine(proposer)
        hasher.combine(totalVotingPower)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidatorSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorSet {
        return
            try ValidatorSet(
                validators: FfiConverterSequenceTypeValidatorInfo.read(from: &buf), 
                proposer: FfiConverterOptionTypeValidatorInfo.read(from: &buf), 
                totalVotingPower: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorSet, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeValidatorInfo.write(value.validators, into: &buf)
        FfiConverterOptionTypeValidatorInfo.write(value.proposer, into: &buf)
        FfiConverterUInt64.write(value.totalVotingPower, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorSet_lift(_ buf: RustBuffer) throws -> ValidatorSet {
    return try FfiConverterTypeValidatorSet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorSet_lower(_ value: ValidatorSet) -> RustBuffer {
    return FfiConverterTypeValidatorSet.lower(value)
}


public struct Vote {
    public var voteType: VoteType
    public var height: BlockHeight
    public var round: UInt32
    public var blockId: BlockId?
    public var timestamp: Time?
    public var validatorAddress: AccountId
    public var validatorIndex: UInt32
    public var signature: Signature?
    public var `extension`: Data
    public var extensionSignature: Signature?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(voteType: VoteType, height: BlockHeight, round: UInt32, blockId: BlockId?, timestamp: Time?, validatorAddress: AccountId, validatorIndex: UInt32, signature: Signature?, `extension`: Data, extensionSignature: Signature?) {
        self.voteType = voteType
        self.height = height
        self.round = round
        self.blockId = blockId
        self.timestamp = timestamp
        self.validatorAddress = validatorAddress
        self.validatorIndex = validatorIndex
        self.signature = signature
        self.`extension` = `extension`
        self.extensionSignature = extensionSignature
    }
}

#if compiler(>=6)
extension Vote: Sendable {}
#endif


extension Vote: Equatable, Hashable {
    public static func ==(lhs: Vote, rhs: Vote) -> Bool {
        if lhs.voteType != rhs.voteType {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.round != rhs.round {
            return false
        }
        if lhs.blockId != rhs.blockId {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.validatorIndex != rhs.validatorIndex {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.`extension` != rhs.`extension` {
            return false
        }
        if lhs.extensionSignature != rhs.extensionSignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(voteType)
        hasher.combine(height)
        hasher.combine(round)
        hasher.combine(blockId)
        hasher.combine(timestamp)
        hasher.combine(validatorAddress)
        hasher.combine(validatorIndex)
        hasher.combine(signature)
        hasher.combine(`extension`)
        hasher.combine(extensionSignature)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vote {
        return
            try Vote(
                voteType: FfiConverterTypeVoteType.read(from: &buf), 
                height: FfiConverterTypeBlockHeight.read(from: &buf), 
                round: FfiConverterUInt32.read(from: &buf), 
                blockId: FfiConverterOptionTypeBlockId.read(from: &buf), 
                timestamp: FfiConverterOptionTypeTime.read(from: &buf), 
                validatorAddress: FfiConverterTypeAccountId.read(from: &buf), 
                validatorIndex: FfiConverterUInt32.read(from: &buf), 
                signature: FfiConverterOptionTypeSignature.read(from: &buf), 
                extension: FfiConverterData.read(from: &buf), 
                extensionSignature: FfiConverterOptionTypeSignature.read(from: &buf)
        )
    }

    public static func write(_ value: Vote, into buf: inout [UInt8]) {
        FfiConverterTypeVoteType.write(value.voteType, into: &buf)
        FfiConverterTypeBlockHeight.write(value.height, into: &buf)
        FfiConverterUInt32.write(value.round, into: &buf)
        FfiConverterOptionTypeBlockId.write(value.blockId, into: &buf)
        FfiConverterOptionTypeTime.write(value.timestamp, into: &buf)
        FfiConverterTypeAccountId.write(value.validatorAddress, into: &buf)
        FfiConverterUInt32.write(value.validatorIndex, into: &buf)
        FfiConverterOptionTypeSignature.write(value.signature, into: &buf)
        FfiConverterData.write(value.`extension`, into: &buf)
        FfiConverterOptionTypeSignature.write(value.extensionSignature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVote_lift(_ buf: RustBuffer) throws -> Vote {
    return try FfiConverterTypeVote.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVote_lower(_ value: Vote) -> RustBuffer {
    return FfiConverterTypeVote.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A Celestia address. Either account, consensus or validator.
 */

public enum Address {
    
    /**
     * Account address.
     */
    case accAddress(AccAddress
    )
    /**
     * Validator address.
     */
    case valAddress(ValAddress
    )
    /**
     * Consensus address.
     */
    case consAddress(ConsAddress
    )
}


#if compiler(>=6)
extension Address: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accAddress(try FfiConverterTypeAccAddress.read(from: &buf)
        )
        
        case 2: return .valAddress(try FfiConverterTypeValAddress.read(from: &buf)
        )
        
        case 3: return .consAddress(try FfiConverterTypeConsAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccAddress.write(v1, into: &buf)
            
        
        case let .valAddress(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeValAddress.write(v1, into: &buf)
            
        
        case let .consAddress(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeConsAddress.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}


extension Address: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum with all valid App versions.
 */

public enum AppVersion : UInt64 {
    
    /**
     * App v1
     */
    case v1 = 1
    /**
     * App v2
     */
    case v2 = 2
    /**
     * App v3
     */
    case v3 = 3
}


#if compiler(>=6)
extension AppVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppVersion: FfiConverterRustBuffer {
    typealias SwiftType = AppVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v1
        
        case 2: return .v2
        
        case 3: return .v3
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v1:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        
        case .v3:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppVersion_lift(_ buf: RustBuffer) throws -> AppVersion {
    return try FfiConverterTypeAppVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppVersion_lower(_ value: AppVersion) -> RustBuffer {
    return FfiConverterTypeAppVersion.lower(value)
}


extension AppVersion: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CommitSig {
    
    case blockIdFlagAbsent
    case blockIdFlagCommit(validatorAddress: AccountId, timestamp: Time, signature: Signature?
    )
    case blockIdFlagNil(validatorAddress: AccountId, timestamp: Time, signature: Signature?
    )
}


#if compiler(>=6)
extension CommitSig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommitSig: FfiConverterRustBuffer {
    typealias SwiftType = CommitSig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommitSig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .blockIdFlagAbsent
        
        case 2: return .blockIdFlagCommit(validatorAddress: try FfiConverterTypeAccountId.read(from: &buf), timestamp: try FfiConverterTypeTime.read(from: &buf), signature: try FfiConverterOptionTypeSignature.read(from: &buf)
        )
        
        case 3: return .blockIdFlagNil(validatorAddress: try FfiConverterTypeAccountId.read(from: &buf), timestamp: try FfiConverterTypeTime.read(from: &buf), signature: try FfiConverterOptionTypeSignature.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommitSig, into buf: inout [UInt8]) {
        switch value {
        
        
        case .blockIdFlagAbsent:
            writeInt(&buf, Int32(1))
        
        
        case let .blockIdFlagCommit(validatorAddress,timestamp,signature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountId.write(validatorAddress, into: &buf)
            FfiConverterTypeTime.write(timestamp, into: &buf)
            FfiConverterOptionTypeSignature.write(signature, into: &buf)
            
        
        case let .blockIdFlagNil(validatorAddress,timestamp,signature):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountId.write(validatorAddress, into: &buf)
            FfiConverterTypeTime.write(timestamp, into: &buf)
            FfiConverterOptionTypeSignature.write(signature, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitSig_lift(_ buf: RustBuffer) throws -> CommitSig {
    return try FfiConverterTypeCommitSig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommitSig_lower(_ value: CommitSig) -> RustBuffer {
    return FfiConverterTypeCommitSig.lower(value)
}


extension CommitSig: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Error codes associated with transaction responses.
 */

public enum ErrorCode : UInt32 {
    
    /**
     * No error
     */
    case success = 0
    /**
     * Cannot parse a transaction
     */
    case txDecode = 2
    /**
     * Sequence number (nonce) is incorrect for the signature
     */
    case invalidSequence = 3
    /**
     * Request without sufficient authorization is handled
     */
    case unauthorized = 4
    /**
     * Account cannot pay requested amount
     */
    case insufficientFunds = 5
    /**
     * Request is unknown
     */
    case unknownRequest = 6
    /**
     * Address is invalid
     */
    case invalidAddress = 7
    /**
     * Pubkey is invalid
     */
    case invalidPubKey = 8
    /**
     * Address is unknown
     */
    case unknownAddress = 9
    /**
     * Coin is invalid
     */
    case invalidCoins = 10
    /**
     * Gas exceeded
     */
    case outOfGas = 11
    /**
     * Memo too large
     */
    case memoTooLarge = 12
    /**
     * Fee is insufficient
     */
    case insufficientFee = 13
    /**
     * Too many signatures
     */
    case tooManySignatures = 14
    /**
     * No signatures in transaction
     */
    case noSignatures = 15
    /**
     * Error converting to json
     */
    case jsonMarshal = 16
    /**
     * Error converting from json
     */
    case jsonUnmarshal = 17
    /**
     * Request contains invalid data
     */
    case invalidRequest = 18
    /**
     * Tx already exists in the mempool
     */
    case txInMempoolCache = 19
    /**
     * Mempool is full
     */
    case mempoolIsFull = 20
    /**
     * Tx is too large
     */
    case txTooLarge = 21
    /**
     * Key doesn't exist
     */
    case keyNotFound = 22
    /**
     * Key password is invalid
     */
    case wrongPassword = 23
    /**
     * Tx intended signer does not match the given signer
     */
    case invalidSigner = 24
    /**
     * Invalid gas adjustment
     */
    case invalidGasAdjustment = 25
    /**
     * Invalid height
     */
    case invalidHeight = 26
    /**
     * Invalid version
     */
    case invalidVersion = 27
    /**
     * Chain-id is invalid
     */
    case invalidChainId = 28
    /**
     * Invalid type
     */
    case invalidType = 29
    /**
     * Tx rejected due to an explicitly set timeout height
     */
    case txTimeoutHeight = 30
    /**
     * Unknown extension options.
     */
    case unknownExtensionOptions = 31
    /**
     * Account sequence defined in the signer info doesn't match the account's actual sequence
     */
    case wrongSequence = 32
    /**
     * Packing a protobuf message to Any failed
     */
    case packAny = 33
    /**
     * Unpacking a protobuf message from Any failed
     */
    case unpackAny = 34
    /**
     * Internal logic error, e.g. an invariant or assertion that is violated
     */
    case logic = 35
    /**
     * Conflict error, e.g. when two goroutines try to access the same resource and one of them fails
     */
    case conflict = 36
    /**
     * Called a branch of a code which is currently not supported
     */
    case notSupported = 37
    /**
     * Requested entity doesn't exist in the state
     */
    case notFound = 38
    /**
     * Internal errors caused by external operation
     */
    case io = 39
    /**
     * Min-gas-prices field in BaseConfig is empty
     */
    case appConfig = 40
    /**
     * Invalid GasWanted value is supplied
     */
    case invalidGasLimit = 41
    /**
     * Node recovered from panic
     */
    case panic = 111222
    /**
     * cannot use reserved namespace IDs
     */
    case reservedNamespace = 11110
    /**
     * invalid namespace length
     */
    case invalidNamespaceLen = 11111
    /**
     * data must be multiple of shareSize
     */
    case invalidDataSize = 11112
    /**
     * actual blob size differs from that specified in the MsgPayForBlob
     */
    case blobSizeMismatch = 11113
    /**
     * committed to invalid square size: must be power of two
     */
    case committedSquareSizeNotPowOf2 = 11114
    /**
     * unexpected error calculating commitment for share
     */
    case calculateCommitment = 11115
    /**
     * invalid commitment for share
     */
    case invalidShareCommitment = 11116
    /**
     * cannot use parity shares namespace ID
     */
    case paritySharesNamespace = 11117
    /**
     * cannot use tail padding namespace ID
     */
    case tailPaddingNamespace = 11118
    /**
     * cannot use transaction namespace ID
     */
    case txNamespace = 11119
    /**
     * invalid share commitments: all relevant square sizes must be committed to
     */
    case invalidShareCommitments = 11122
    /**
     * unsupported share version
     */
    case unsupportedShareVersion = 11123
    /**
     * cannot use zero blob size
     */
    case zeroBlobSize = 11124
    /**
     * mismatched number of blobs per MsgPayForBlob
     */
    case mismatchedNumberOfPfBorBlob = 11125
    /**
     * no MsgPayForBlobs found in blob transaction
     */
    case noPfb = 11126
    /**
     * namespace of blob and its respective MsgPayForBlobs differ
     */
    case namespaceMismatch = 11127
    /**
     * failure to parse a transaction from its protobuf representation
     */
    case protoParsing = 11128
    /**
     * not yet supported: multiple sdk.Msgs found in BlobTx
     */
    case multipleMsgsInBlobTx = 11129
    /**
     * number of each component in a MsgPayForBlobs must be identical
     */
    case mismatchedNumberOfPfbComponent = 11130
    /**
     * no blobs provided
     */
    case noBlobs = 11131
    /**
     * no namespaces provided
     */
    case noNamespaces = 11132
    /**
     * no share versions provided
     */
    case noShareVersions = 11133
    /**
     * no blob sizes provided
     */
    case noBlobSizes = 11134
    /**
     * no share commitments provided
     */
    case noShareCommitments = 11135
    /**
     * invalid namespace
     */
    case invalidNamespace = 11136
    /**
     * invalid namespace version
     */
    case invalidNamespaceVersion = 11137
    /**
     * total blob size too large
     *
     * TotalBlobSize is deprecated, use BlobsTooLarge instead.
     */
    case totalBlobSizeTooLarge = 11138
    /**
     * blob(s) too large
     */
    case blobsTooLarge = 11139
    /**
     * invalid blob signer
     */
    case invalidBlobSigner = 11140
}


#if compiler(>=6)
extension ErrorCode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .txDecode
        
        case 3: return .invalidSequence
        
        case 4: return .unauthorized
        
        case 5: return .insufficientFunds
        
        case 6: return .unknownRequest
        
        case 7: return .invalidAddress
        
        case 8: return .invalidPubKey
        
        case 9: return .unknownAddress
        
        case 10: return .invalidCoins
        
        case 11: return .outOfGas
        
        case 12: return .memoTooLarge
        
        case 13: return .insufficientFee
        
        case 14: return .tooManySignatures
        
        case 15: return .noSignatures
        
        case 16: return .jsonMarshal
        
        case 17: return .jsonUnmarshal
        
        case 18: return .invalidRequest
        
        case 19: return .txInMempoolCache
        
        case 20: return .mempoolIsFull
        
        case 21: return .txTooLarge
        
        case 22: return .keyNotFound
        
        case 23: return .wrongPassword
        
        case 24: return .invalidSigner
        
        case 25: return .invalidGasAdjustment
        
        case 26: return .invalidHeight
        
        case 27: return .invalidVersion
        
        case 28: return .invalidChainId
        
        case 29: return .invalidType
        
        case 30: return .txTimeoutHeight
        
        case 31: return .unknownExtensionOptions
        
        case 32: return .wrongSequence
        
        case 33: return .packAny
        
        case 34: return .unpackAny
        
        case 35: return .logic
        
        case 36: return .conflict
        
        case 37: return .notSupported
        
        case 38: return .notFound
        
        case 39: return .io
        
        case 40: return .appConfig
        
        case 41: return .invalidGasLimit
        
        case 42: return .panic
        
        case 43: return .reservedNamespace
        
        case 44: return .invalidNamespaceLen
        
        case 45: return .invalidDataSize
        
        case 46: return .blobSizeMismatch
        
        case 47: return .committedSquareSizeNotPowOf2
        
        case 48: return .calculateCommitment
        
        case 49: return .invalidShareCommitment
        
        case 50: return .paritySharesNamespace
        
        case 51: return .tailPaddingNamespace
        
        case 52: return .txNamespace
        
        case 53: return .invalidShareCommitments
        
        case 54: return .unsupportedShareVersion
        
        case 55: return .zeroBlobSize
        
        case 56: return .mismatchedNumberOfPfBorBlob
        
        case 57: return .noPfb
        
        case 58: return .namespaceMismatch
        
        case 59: return .protoParsing
        
        case 60: return .multipleMsgsInBlobTx
        
        case 61: return .mismatchedNumberOfPfbComponent
        
        case 62: return .noBlobs
        
        case 63: return .noNamespaces
        
        case 64: return .noShareVersions
        
        case 65: return .noBlobSizes
        
        case 66: return .noShareCommitments
        
        case 67: return .invalidNamespace
        
        case 68: return .invalidNamespaceVersion
        
        case 69: return .totalBlobSizeTooLarge
        
        case 70: return .blobsTooLarge
        
        case 71: return .invalidBlobSigner
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case .txDecode:
            writeInt(&buf, Int32(2))
        
        
        case .invalidSequence:
            writeInt(&buf, Int32(3))
        
        
        case .unauthorized:
            writeInt(&buf, Int32(4))
        
        
        case .insufficientFunds:
            writeInt(&buf, Int32(5))
        
        
        case .unknownRequest:
            writeInt(&buf, Int32(6))
        
        
        case .invalidAddress:
            writeInt(&buf, Int32(7))
        
        
        case .invalidPubKey:
            writeInt(&buf, Int32(8))
        
        
        case .unknownAddress:
            writeInt(&buf, Int32(9))
        
        
        case .invalidCoins:
            writeInt(&buf, Int32(10))
        
        
        case .outOfGas:
            writeInt(&buf, Int32(11))
        
        
        case .memoTooLarge:
            writeInt(&buf, Int32(12))
        
        
        case .insufficientFee:
            writeInt(&buf, Int32(13))
        
        
        case .tooManySignatures:
            writeInt(&buf, Int32(14))
        
        
        case .noSignatures:
            writeInt(&buf, Int32(15))
        
        
        case .jsonMarshal:
            writeInt(&buf, Int32(16))
        
        
        case .jsonUnmarshal:
            writeInt(&buf, Int32(17))
        
        
        case .invalidRequest:
            writeInt(&buf, Int32(18))
        
        
        case .txInMempoolCache:
            writeInt(&buf, Int32(19))
        
        
        case .mempoolIsFull:
            writeInt(&buf, Int32(20))
        
        
        case .txTooLarge:
            writeInt(&buf, Int32(21))
        
        
        case .keyNotFound:
            writeInt(&buf, Int32(22))
        
        
        case .wrongPassword:
            writeInt(&buf, Int32(23))
        
        
        case .invalidSigner:
            writeInt(&buf, Int32(24))
        
        
        case .invalidGasAdjustment:
            writeInt(&buf, Int32(25))
        
        
        case .invalidHeight:
            writeInt(&buf, Int32(26))
        
        
        case .invalidVersion:
            writeInt(&buf, Int32(27))
        
        
        case .invalidChainId:
            writeInt(&buf, Int32(28))
        
        
        case .invalidType:
            writeInt(&buf, Int32(29))
        
        
        case .txTimeoutHeight:
            writeInt(&buf, Int32(30))
        
        
        case .unknownExtensionOptions:
            writeInt(&buf, Int32(31))
        
        
        case .wrongSequence:
            writeInt(&buf, Int32(32))
        
        
        case .packAny:
            writeInt(&buf, Int32(33))
        
        
        case .unpackAny:
            writeInt(&buf, Int32(34))
        
        
        case .logic:
            writeInt(&buf, Int32(35))
        
        
        case .conflict:
            writeInt(&buf, Int32(36))
        
        
        case .notSupported:
            writeInt(&buf, Int32(37))
        
        
        case .notFound:
            writeInt(&buf, Int32(38))
        
        
        case .io:
            writeInt(&buf, Int32(39))
        
        
        case .appConfig:
            writeInt(&buf, Int32(40))
        
        
        case .invalidGasLimit:
            writeInt(&buf, Int32(41))
        
        
        case .panic:
            writeInt(&buf, Int32(42))
        
        
        case .reservedNamespace:
            writeInt(&buf, Int32(43))
        
        
        case .invalidNamespaceLen:
            writeInt(&buf, Int32(44))
        
        
        case .invalidDataSize:
            writeInt(&buf, Int32(45))
        
        
        case .blobSizeMismatch:
            writeInt(&buf, Int32(46))
        
        
        case .committedSquareSizeNotPowOf2:
            writeInt(&buf, Int32(47))
        
        
        case .calculateCommitment:
            writeInt(&buf, Int32(48))
        
        
        case .invalidShareCommitment:
            writeInt(&buf, Int32(49))
        
        
        case .paritySharesNamespace:
            writeInt(&buf, Int32(50))
        
        
        case .tailPaddingNamespace:
            writeInt(&buf, Int32(51))
        
        
        case .txNamespace:
            writeInt(&buf, Int32(52))
        
        
        case .invalidShareCommitments:
            writeInt(&buf, Int32(53))
        
        
        case .unsupportedShareVersion:
            writeInt(&buf, Int32(54))
        
        
        case .zeroBlobSize:
            writeInt(&buf, Int32(55))
        
        
        case .mismatchedNumberOfPfBorBlob:
            writeInt(&buf, Int32(56))
        
        
        case .noPfb:
            writeInt(&buf, Int32(57))
        
        
        case .namespaceMismatch:
            writeInt(&buf, Int32(58))
        
        
        case .protoParsing:
            writeInt(&buf, Int32(59))
        
        
        case .multipleMsgsInBlobTx:
            writeInt(&buf, Int32(60))
        
        
        case .mismatchedNumberOfPfbComponent:
            writeInt(&buf, Int32(61))
        
        
        case .noBlobs:
            writeInt(&buf, Int32(62))
        
        
        case .noNamespaces:
            writeInt(&buf, Int32(63))
        
        
        case .noShareVersions:
            writeInt(&buf, Int32(64))
        
        
        case .noBlobSizes:
            writeInt(&buf, Int32(65))
        
        
        case .noShareCommitments:
            writeInt(&buf, Int32(66))
        
        
        case .invalidNamespace:
            writeInt(&buf, Int32(67))
        
        
        case .invalidNamespaceVersion:
            writeInt(&buf, Int32(68))
        
        
        case .totalBlobSizeTooLarge:
            writeInt(&buf, Int32(69))
        
        
        case .blobsTooLarge:
            writeInt(&buf, Int32(70))
        
        
        case .invalidBlobSigner:
            writeInt(&buf, Int32(71))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorCode_lift(_ buf: RustBuffer) throws -> ErrorCode {
    return try FfiConverterTypeErrorCode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorCode_lower(_ value: ErrorCode) -> RustBuffer {
    return FfiConverterTypeErrorCode.lower(value)
}


extension ErrorCode: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Evidence {
    
    case duplicateVote(voteA: Vote, voteB: Vote, totalVotingPower: UInt64, validatorPower: UInt64, timestamp: Time
    )
    case lightClientAttack(conflictingBlock: ConflictingBlock, commonHeight: UInt64, byzantineValidators: [ValidatorInfo], totalVotingPower: UInt64, timestamp: Time
    )
}


#if compiler(>=6)
extension Evidence: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvidence: FfiConverterRustBuffer {
    typealias SwiftType = Evidence

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Evidence {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .duplicateVote(voteA: try FfiConverterTypeVote.read(from: &buf), voteB: try FfiConverterTypeVote.read(from: &buf), totalVotingPower: try FfiConverterUInt64.read(from: &buf), validatorPower: try FfiConverterUInt64.read(from: &buf), timestamp: try FfiConverterTypeTime.read(from: &buf)
        )
        
        case 2: return .lightClientAttack(conflictingBlock: try FfiConverterTypeConflictingBlock.read(from: &buf), commonHeight: try FfiConverterUInt64.read(from: &buf), byzantineValidators: try FfiConverterSequenceTypeValidatorInfo.read(from: &buf), totalVotingPower: try FfiConverterUInt64.read(from: &buf), timestamp: try FfiConverterTypeTime.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Evidence, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .duplicateVote(voteA,voteB,totalVotingPower,validatorPower,timestamp):
            writeInt(&buf, Int32(1))
            FfiConverterTypeVote.write(voteA, into: &buf)
            FfiConverterTypeVote.write(voteB, into: &buf)
            FfiConverterUInt64.write(totalVotingPower, into: &buf)
            FfiConverterUInt64.write(validatorPower, into: &buf)
            FfiConverterTypeTime.write(timestamp, into: &buf)
            
        
        case let .lightClientAttack(conflictingBlock,commonHeight,byzantineValidators,totalVotingPower,timestamp):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConflictingBlock.write(conflictingBlock, into: &buf)
            FfiConverterUInt64.write(commonHeight, into: &buf)
            FfiConverterSequenceTypeValidatorInfo.write(byzantineValidators, into: &buf)
            FfiConverterUInt64.write(totalVotingPower, into: &buf)
            FfiConverterTypeTime.write(timestamp, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvidence_lift(_ buf: RustBuffer) throws -> Evidence {
    return try FfiConverterTypeEvidence.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvidence_lower(_ value: Evidence) -> RustBuffer {
    return FfiConverterTypeEvidence.lower(value)
}


extension Evidence: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PublicKey {
    
    case ed25519(bytes: Data
    )
    case secp256k1(sec1Bytes: Data
    )
}


#if compiler(>=6)
extension PublicKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519(bytes: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .secp256k1(sec1Bytes: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ed25519(bytes):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(bytes, into: &buf)
            
        
        case let .secp256k1(sec1Bytes):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(sec1Bytes, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}


extension PublicKey: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * sum is the oneof that specifies whether this represents a single or nested
 * multisig signer
 */

public enum Sum {
    
    /**
     * Single is the mode info for a single signer. It is structured as a message
     * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
     * future
     */
    case single(
        /**
         * mode is the signing mode of the single signer
         */mode: Int32
    )
    /**
     * Multi is the mode info for a multisig public key
     */
    case multi(
        /**
         * bitarray specifies which keys within the multisig are signing
         */bitarray: LuminaBitVector, 
        /**
         * mode_infos is the corresponding modes of the signers of the multisig
         * which could include nested multisig public keys
         */modeInfos: [ModeInfo]
    )
}


#if compiler(>=6)
extension Sum: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSum: FfiConverterRustBuffer {
    typealias SwiftType = Sum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single(mode: try FfiConverterInt32.read(from: &buf)
        )
        
        case 2: return .multi(bitarray: try FfiConverterTypeLuminaBitVector.read(from: &buf), modeInfos: try FfiConverterSequenceTypeModeInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Sum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .single(mode):
            writeInt(&buf, Int32(1))
            FfiConverterInt32.write(mode, into: &buf)
            
        
        case let .multi(bitarray,modeInfos):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLuminaBitVector.write(bitarray, into: &buf)
            FfiConverterSequenceTypeModeInfo.write(modeInfos, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSum_lift(_ buf: RustBuffer) throws -> Sum {
    return try FfiConverterTypeSum.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSum_lower(_ value: Sum) -> RustBuffer {
    return FfiConverterTypeSum.lower(value)
}


extension Sum: Equatable, Hashable {}







public enum UniffiError: Swift.Error {

    
    
    case InvalidNamespaceLength
    case InvalidCommitmentLength
    case InvalidAccountIdLength
    case InvalidHashLength
    case InvalidChainIdLength
    case InvalidPublicKey
    case InvalidPartsHeader(msg: String
    )
    case TimestampOutOfRange
    case HeaderHeightOutOfRange
    case InvalidSignatureLength
    case InvalidRoundIndex
    case InvalidValidatorIndex
    case InvalidVotingPower
    case InvalidSignedHeader
    case CouldNotGenerateCommitment(msg: String
    )
    case InvalidAddress(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUniffiError: FfiConverterRustBuffer {
    typealias SwiftType = UniffiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidNamespaceLength
        case 2: return .InvalidCommitmentLength
        case 3: return .InvalidAccountIdLength
        case 4: return .InvalidHashLength
        case 5: return .InvalidChainIdLength
        case 6: return .InvalidPublicKey
        case 7: return .InvalidPartsHeader(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 8: return .TimestampOutOfRange
        case 9: return .HeaderHeightOutOfRange
        case 10: return .InvalidSignatureLength
        case 11: return .InvalidRoundIndex
        case 12: return .InvalidValidatorIndex
        case 13: return .InvalidVotingPower
        case 14: return .InvalidSignedHeader
        case 15: return .CouldNotGenerateCommitment(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 16: return .InvalidAddress(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UniffiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidNamespaceLength:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidCommitmentLength:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidAccountIdLength:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidHashLength:
            writeInt(&buf, Int32(4))
        
        
        case .InvalidChainIdLength:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidPublicKey:
            writeInt(&buf, Int32(6))
        
        
        case let .InvalidPartsHeader(msg):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(msg, into: &buf)
            
        
        case .TimestampOutOfRange:
            writeInt(&buf, Int32(8))
        
        
        case .HeaderHeightOutOfRange:
            writeInt(&buf, Int32(9))
        
        
        case .InvalidSignatureLength:
            writeInt(&buf, Int32(10))
        
        
        case .InvalidRoundIndex:
            writeInt(&buf, Int32(11))
        
        
        case .InvalidValidatorIndex:
            writeInt(&buf, Int32(12))
        
        
        case .InvalidVotingPower:
            writeInt(&buf, Int32(13))
        
        
        case .InvalidSignedHeader:
            writeInt(&buf, Int32(14))
        
        
        case let .CouldNotGenerateCommitment(msg):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidAddress(msg):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiError_lift(_ buf: RustBuffer) throws -> UniffiError {
    return try FfiConverterTypeUniffiError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiError_lower(_ value: UniffiError) -> RustBuffer {
    return FfiConverterTypeUniffiError.lower(value)
}


extension UniffiError: Equatable, Hashable {}




extension UniffiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UniffiHash {
    
    case sha256(hash: Data
    )
    case none
}


#if compiler(>=6)
extension UniffiHash: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUniffiHash: FfiConverterRustBuffer {
    typealias SwiftType = UniffiHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sha256(hash: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UniffiHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .sha256(hash):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(hash, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiHash_lift(_ buf: RustBuffer) throws -> UniffiHash {
    return try FfiConverterTypeUniffiHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUniffiHash_lower(_ value: UniffiHash) -> RustBuffer {
    return FfiConverterTypeUniffiHash.lower(value)
}


extension UniffiHash: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VoteType : UInt8 {
    
    case prevote = 1
    case precommit = 2
}


#if compiler(>=6)
extension VoteType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVoteType: FfiConverterRustBuffer {
    typealias SwiftType = VoteType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VoteType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .prevote
        
        case 2: return .precommit
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VoteType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .prevote:
            writeInt(&buf, Int32(1))
        
        
        case .precommit:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVoteType_lift(_ buf: RustBuffer) throws -> VoteType {
    return try FfiConverterTypeVoteType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVoteType_lower(_ value: VoteType) -> RustBuffer {
    return FfiConverterTypeVoteType.lower(value)
}


extension VoteType: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAccAddress: FfiConverterRustBuffer {
    typealias SwiftType = AccAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBlockId: FfiConverterRustBuffer {
    typealias SwiftType = BlockId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeProtobufAny: FfiConverterRustBuffer {
    typealias SwiftType = ProtobufAny?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProtobufAny.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProtobufAny.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignature.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignature.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTime: FfiConverterRustBuffer {
    typealias SwiftType = Time?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeValidatorInfo: FfiConverterRustBuffer {
    typealias SwiftType = ValidatorInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeValidatorInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeValidatorInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTendermintCommit: FfiConverterRustBuffer {
    typealias SwiftType = TendermintCommit?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTendermintCommit.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTendermintCommit.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTendermintHash: FfiConverterRustBuffer {
    typealias SwiftType = TendermintHash?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTendermintHash.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTendermintHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTendermintPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = TendermintPublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTendermintPublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTendermintPublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAbciMessageLog: FfiConverterRustBuffer {
    typealias SwiftType = [AbciMessageLog]

    public static func write(_ value: [AbciMessageLog], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAbciMessageLog.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AbciMessageLog] {
        let len: Int32 = try readInt(&buf)
        var seq = [AbciMessageLog]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAbciMessageLog.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCoin: FfiConverterRustBuffer {
    typealias SwiftType = [Coin]

    public static func write(_ value: [Coin], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoin.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Coin] {
        let len: Int32 = try readInt(&buf)
        var seq = [Coin]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCoin.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEventAttribute: FfiConverterRustBuffer {
    typealias SwiftType = [EventAttribute]

    public static func write(_ value: [EventAttribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventAttribute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventAttribute] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventAttribute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventAttribute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeModeInfo: FfiConverterRustBuffer {
    typealias SwiftType = [ModeInfo]

    public static func write(_ value: [ModeInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeModeInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ModeInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [ModeInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeModeInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProtobufAny: FfiConverterRustBuffer {
    typealias SwiftType = [ProtobufAny]

    public static func write(_ value: [ProtobufAny], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProtobufAny.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProtobufAny] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProtobufAny]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProtobufAny.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSignerInfo: FfiConverterRustBuffer {
    typealias SwiftType = [SignerInfo]

    public static func write(_ value: [SignerInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSignerInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SignerInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [SignerInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSignerInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeValidatorInfo: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorInfo]

    public static func write(_ value: [ValidatorInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValidatorInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCommitSig: FfiConverterRustBuffer {
    typealias SwiftType = [CommitSig]

    public static func write(_ value: [CommitSig], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCommitSig.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CommitSig] {
        let len: Int32 = try readInt(&buf)
        var seq = [CommitSig]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCommitSig.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEvidence: FfiConverterRustBuffer {
    typealias SwiftType = [Evidence]

    public static func write(_ value: [Evidence], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvidence.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Evidence] {
        let len: Int32 = try readInt(&buf)
        var seq = [Evidence]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvidence.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Id = AccountId

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Id {
        return try FfiConverterTypeAccountId.read(from: &buf)
    }

    public static func write(_ value: Id, into buf: inout [UInt8]) {
        return FfiConverterTypeAccountId.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Id {
        return try FfiConverterTypeAccountId_lift(value)
    }

    public static func lower(_ value: Id) -> RustBuffer {
        return FfiConverterTypeAccountId_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeId_lift(_ value: RustBuffer) throws -> Id {
    return try FfiConverterTypeId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeId_lower(_ value: Id) -> RustBuffer {
    return FfiConverterTypeId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LuminaBitVector = BitVector

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLuminaBitVector: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LuminaBitVector {
        return try FfiConverterTypeBitVector.read(from: &buf)
    }

    public static func write(_ value: LuminaBitVector, into buf: inout [UInt8]) {
        return FfiConverterTypeBitVector.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LuminaBitVector {
        return try FfiConverterTypeBitVector_lift(value)
    }

    public static func lower(_ value: LuminaBitVector) -> RustBuffer {
        return FfiConverterTypeBitVector_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLuminaBitVector_lift(_ value: RustBuffer) throws -> LuminaBitVector {
    return try FfiConverterTypeLuminaBitVector.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLuminaBitVector_lower(_ value: LuminaBitVector) -> RustBuffer {
    return FfiConverterTypeLuminaBitVector.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RawBytes = Bytes

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRawBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RawBytes {
        return try FfiConverterTypeBytes.read(from: &buf)
    }

    public static func write(_ value: RawBytes, into buf: inout [UInt8]) {
        return FfiConverterTypeBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RawBytes {
        return try FfiConverterTypeBytes_lift(value)
    }

    public static func lower(_ value: RawBytes) -> RustBuffer {
        return FfiConverterTypeBytes_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRawBytes_lift(_ value: RustBuffer) throws -> RawBytes {
    return try FfiConverterTypeRawBytes.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRawBytes_lower(_ value: RawBytes) -> RustBuffer {
    return FfiConverterTypeRawBytes.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RustCommitment = Commitment

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustCommitment: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustCommitment {
        return try FfiConverterTypeCommitment.read(from: &buf)
    }

    public static func write(_ value: RustCommitment, into buf: inout [UInt8]) {
        return FfiConverterTypeCommitment.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RustCommitment {
        return try FfiConverterTypeCommitment_lift(value)
    }

    public static func lower(_ value: RustCommitment) -> RustBuffer {
        return FfiConverterTypeCommitment_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustCommitment_lift(_ value: RustBuffer) throws -> RustCommitment {
    return try FfiConverterTypeRustCommitment.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustCommitment_lower(_ value: RustCommitment) -> RustBuffer {
    return FfiConverterTypeRustCommitment.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RustNamespace = Namespace

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustNamespace: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustNamespace {
        return try FfiConverterTypeNamespace.read(from: &buf)
    }

    public static func write(_ value: RustNamespace, into buf: inout [UInt8]) {
        return FfiConverterTypeNamespace.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RustNamespace {
        return try FfiConverterTypeNamespace_lift(value)
    }

    public static func lower(_ value: RustNamespace) -> RustBuffer {
        return FfiConverterTypeNamespace_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustNamespace_lift(_ value: RustBuffer) throws -> RustNamespace {
    return try FfiConverterTypeRustNamespace.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustNamespace_lower(_ value: RustNamespace) -> RustBuffer {
    return FfiConverterTypeRustNamespace.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintAppHash = AppHash

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintAppHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintAppHash {
        return try FfiConverterTypeAppHash.read(from: &buf)
    }

    public static func write(_ value: TendermintAppHash, into buf: inout [UInt8]) {
        return FfiConverterTypeAppHash.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintAppHash {
        return try FfiConverterTypeAppHash_lift(value)
    }

    public static func lower(_ value: TendermintAppHash) -> RustBuffer {
        return FfiConverterTypeAppHash_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintAppHash_lift(_ value: RustBuffer) throws -> TendermintAppHash {
    return try FfiConverterTypeTendermintAppHash.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintAppHash_lower(_ value: TendermintAppHash) -> RustBuffer {
    return FfiConverterTypeTendermintAppHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintBlockId = BlockId

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintBlockId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintBlockId {
        return try FfiConverterTypeBlockId.read(from: &buf)
    }

    public static func write(_ value: TendermintBlockId, into buf: inout [UInt8]) {
        return FfiConverterTypeBlockId.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintBlockId {
        return try FfiConverterTypeBlockId_lift(value)
    }

    public static func lower(_ value: TendermintBlockId) -> RustBuffer {
        return FfiConverterTypeBlockId_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintBlockId_lift(_ value: RustBuffer) throws -> TendermintBlockId {
    return try FfiConverterTypeTendermintBlockId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintBlockId_lower(_ value: TendermintBlockId) -> RustBuffer {
    return FfiConverterTypeTendermintBlockId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintChainId = ChainId

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintChainId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintChainId {
        return try FfiConverterTypeChainId.read(from: &buf)
    }

    public static func write(_ value: TendermintChainId, into buf: inout [UInt8]) {
        return FfiConverterTypeChainId.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintChainId {
        return try FfiConverterTypeChainId_lift(value)
    }

    public static func lower(_ value: TendermintChainId) -> RustBuffer {
        return FfiConverterTypeChainId_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintChainId_lift(_ value: RustBuffer) throws -> TendermintChainId {
    return try FfiConverterTypeTendermintChainId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintChainId_lower(_ value: TendermintChainId) -> RustBuffer {
    return FfiConverterTypeTendermintChainId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintCommit = Commit

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintCommit: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintCommit {
        return try FfiConverterTypeCommit.read(from: &buf)
    }

    public static func write(_ value: TendermintCommit, into buf: inout [UInt8]) {
        return FfiConverterTypeCommit.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintCommit {
        return try FfiConverterTypeCommit_lift(value)
    }

    public static func lower(_ value: TendermintCommit) -> RustBuffer {
        return FfiConverterTypeCommit_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintCommit_lift(_ value: RustBuffer) throws -> TendermintCommit {
    return try FfiConverterTypeTendermintCommit.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintCommit_lower(_ value: TendermintCommit) -> RustBuffer {
    return FfiConverterTypeTendermintCommit.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintEvidenceList = [Evidence]

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintEvidenceList: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintEvidenceList {
        return try FfiConverterSequenceTypeEvidence.read(from: &buf)
    }

    public static func write(_ value: TendermintEvidenceList, into buf: inout [UInt8]) {
        return FfiConverterSequenceTypeEvidence.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintEvidenceList {
        return try FfiConverterSequenceTypeEvidence.lift(value)
    }

    public static func lower(_ value: TendermintEvidenceList) -> RustBuffer {
        return FfiConverterSequenceTypeEvidence.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintEvidenceList_lift(_ value: RustBuffer) throws -> TendermintEvidenceList {
    return try FfiConverterTypeTendermintEvidenceList.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintEvidenceList_lower(_ value: TendermintEvidenceList) -> RustBuffer {
    return FfiConverterTypeTendermintEvidenceList.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintHash = UniffiHash

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintHash {
        return try FfiConverterTypeUniffiHash.read(from: &buf)
    }

    public static func write(_ value: TendermintHash, into buf: inout [UInt8]) {
        return FfiConverterTypeUniffiHash.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintHash {
        return try FfiConverterTypeUniffiHash_lift(value)
    }

    public static func lower(_ value: TendermintHash) -> RustBuffer {
        return FfiConverterTypeUniffiHash_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHash_lift(_ value: RustBuffer) throws -> TendermintHash {
    return try FfiConverterTypeTendermintHash.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHash_lower(_ value: TendermintHash) -> RustBuffer {
    return FfiConverterTypeTendermintHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintHeader = Header

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintHeader: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintHeader {
        return try FfiConverterTypeHeader.read(from: &buf)
    }

    public static func write(_ value: TendermintHeader, into buf: inout [UInt8]) {
        return FfiConverterTypeHeader.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintHeader {
        return try FfiConverterTypeHeader_lift(value)
    }

    public static func lower(_ value: TendermintHeader) -> RustBuffer {
        return FfiConverterTypeHeader_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHeader_lift(_ value: RustBuffer) throws -> TendermintHeader {
    return try FfiConverterTypeTendermintHeader.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHeader_lower(_ value: TendermintHeader) -> RustBuffer {
    return FfiConverterTypeTendermintHeader.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintHeight = BlockHeight

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintHeight: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintHeight {
        return try FfiConverterTypeBlockHeight.read(from: &buf)
    }

    public static func write(_ value: TendermintHeight, into buf: inout [UInt8]) {
        return FfiConverterTypeBlockHeight.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintHeight {
        return try FfiConverterTypeBlockHeight_lift(value)
    }

    public static func lower(_ value: TendermintHeight) -> RustBuffer {
        return FfiConverterTypeBlockHeight_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHeight_lift(_ value: RustBuffer) throws -> TendermintHeight {
    return try FfiConverterTypeTendermintHeight.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintHeight_lower(_ value: TendermintHeight) -> RustBuffer {
    return FfiConverterTypeTendermintHeight.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintPublicKey = PublicKey

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintPublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintPublicKey {
        return try FfiConverterTypePublicKey.read(from: &buf)
    }

    public static func write(_ value: TendermintPublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintPublicKey {
        return try FfiConverterTypePublicKey_lift(value)
    }

    public static func lower(_ value: TendermintPublicKey) -> RustBuffer {
        return FfiConverterTypePublicKey_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintPublicKey_lift(_ value: RustBuffer) throws -> TendermintPublicKey {
    return try FfiConverterTypeTendermintPublicKey.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintPublicKey_lower(_ value: TendermintPublicKey) -> RustBuffer {
    return FfiConverterTypeTendermintPublicKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintSignature = Signature

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintSignature: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintSignature {
        return try FfiConverterTypeSignature.read(from: &buf)
    }

    public static func write(_ value: TendermintSignature, into buf: inout [UInt8]) {
        return FfiConverterTypeSignature.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintSignature {
        return try FfiConverterTypeSignature_lift(value)
    }

    public static func lower(_ value: TendermintSignature) -> RustBuffer {
        return FfiConverterTypeSignature_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintSignature_lift(_ value: RustBuffer) throws -> TendermintSignature {
    return try FfiConverterTypeTendermintSignature.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintSignature_lower(_ value: TendermintSignature) -> RustBuffer {
    return FfiConverterTypeTendermintSignature.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintTime = Time

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintTime {
        return try FfiConverterTypeTime.read(from: &buf)
    }

    public static func write(_ value: TendermintTime, into buf: inout [UInt8]) {
        return FfiConverterTypeTime.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintTime {
        return try FfiConverterTypeTime_lift(value)
    }

    public static func lower(_ value: TendermintTime) -> RustBuffer {
        return FfiConverterTypeTime_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintTime_lift(_ value: RustBuffer) throws -> TendermintTime {
    return try FfiConverterTypeTendermintTime.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintTime_lower(_ value: TendermintTime) -> RustBuffer {
    return FfiConverterTypeTendermintTime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TendermintVote = Vote

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTendermintVote: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TendermintVote {
        return try FfiConverterTypeVote.read(from: &buf)
    }

    public static func write(_ value: TendermintVote, into buf: inout [UInt8]) {
        return FfiConverterTypeVote.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> TendermintVote {
        return try FfiConverterTypeVote_lift(value)
    }

    public static func lower(_ value: TendermintVote) -> RustBuffer {
        return FfiConverterTypeVote_lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintVote_lift(_ value: RustBuffer) throws -> TendermintVote {
    return try FfiConverterTypeTendermintVote.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTendermintVote_lower(_ value: TendermintVote) -> RustBuffer {
    return FfiConverterTypeTendermintVote.lower(value)
}

public func newBlob(namespace: RustNamespace, data: Data, appVersion: AppVersion)throws  -> Blob  {
    return try  FfiConverterTypeBlob_lift(try rustCallWithError(FfiConverterTypeUniffiError_lift) {
    uniffi_celestia_types_fn_func_new_blob(
        FfiConverterTypeRustNamespace_lower(namespace),
        FfiConverterData.lower(data),
        FfiConverterTypeAppVersion_lower(appVersion),$0
    )
})
}
public func newV0Namespace(id: Data)throws  -> Namespace  {
    return try  FfiConverterTypeNamespace_lift(try rustCallWithError(FfiConverterTypeUniffiError_lift) {
    uniffi_celestia_types_fn_func_new_v0_namespace(
        FfiConverterData.lower(id),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_celestia_types_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_celestia_types_checksum_func_new_blob() != 26115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_celestia_types_checksum_func_new_v0_namespace() != 44395) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiEnsureCelestiaProtoInitialized()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureCelestiaTypesInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all